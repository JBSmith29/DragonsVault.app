{% extends "base.html" %}
{% block content %}
<div class="container py-4">
{% set selected_mode = (quantity_mode or 'new_only') if quantity_mode is defined else 'new_only' %}
  {% set manual_seed = session.get('manual_import_seed') %}
  {% set field_errors = field_errors or {} %}
  {% set form_errors = form_errors or [] %}

  <div class="d-flex flex-wrap align-items-center justify-content-between gap-3 mb-2">
    <div>
      <h1 class="mb-1">Import / Export Cards</h1>
      <p class="text-muted mb-0">
        Upload a CSV or Excel export and pick how to apply it. By default we only add new cards, so you won't accidentally
        bump quantities you already have. Use <em>Clear &amp; import</em> if this file is your entire collection and should replace what's stored now.
      </p>
    </div>
    <div class="d-flex flex-wrap gap-2">
      <a class="btn btn-outline-primary" href="{{ url_for('views.manage_folder_preferences') }}">Manage Folders</a>
      {% if manual_seed %}
        <a class="btn btn-outline-info" href="{{ url_for('views.manual_import') }}">
          Review skipped cards
        </a>
      {% endif %}
    </div>
  </div>

  {% if manual_seed %}
    <div class="alert alert-info" role="alert">
      Skipped cards from your last import were sent to the Manual Import wizard.
      <a href="{{ url_for('views.manual_import') }}" class="alert-link">Open manual import</a>.
    </div>
  {% endif %}
  {% if notification %}
    <div class="alert alert-{{ notification.level or 'info' }} alert-dismissible fade show" role="alert">
      {{ notification.message }}
      <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>
  {% endif %}
  <div class="alert alert-success alert-dismissible fade show d-none" role="alert" id="importSummaryAlert">
    <div class="fw-semibold" id="importSummaryTitle">Import completed</div>
    <div class="small text-muted" id="importSummaryDetails"></div>
    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
  </div>

  <style>
    .folder-export-grid {
      display: grid;
      gap: 0.75rem;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .folder-export-surface {
      background: rgba(15, 23, 42, 0.35);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 1rem;
      padding: 1.25rem;
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.04),
        0 0.25rem 1.25rem rgba(15, 15, 20, 0.25);
      backdrop-filter: blur(8px);
    }
    .folder-export-card {
      position: relative;
      display: block;
      cursor: pointer;
    }
    .folder-export-card input[type="checkbox"] {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }
    .folder-export-card-body {
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 0.85rem;
      padding: 0.85rem;
      background: rgba(18, 24, 38, 0.65);
      transition:
        border-color 0.18s ease,
        box-shadow 0.18s ease,
        background 0.18s ease;
      min-height: 92px;
    }
    .folder-export-card:hover .folder-export-card-body {
      border-color: rgba(25, 135, 84, 0.4);
    }
    .folder-export-card input[type="checkbox"]:checked + .folder-export-card-body {
      border-color: rgba(25, 135, 84, 0.9);
      box-shadow: 0 0 0 2px rgba(25, 135, 84, 0.2);
      background: rgba(25, 135, 84, 0.05);
    }
    .folder-export-card input[type="checkbox"]:disabled + .folder-export-card-body {
      opacity: 0.55;
      cursor: not-allowed;
    }
    .folder-export-card input[type="checkbox"]:focus-visible + .folder-export-card-body {
      outline: 2px solid rgba(13, 110, 253, 0.6);
      outline-offset: 2px;
    }
    @media (prefers-color-scheme: light) {
      .folder-export-surface {
        background: rgba(255, 255, 255, 0.75);
        border-color: rgba(148, 163, 184, 0.25);
        box-shadow:
          inset 0 1px 0 rgba(255, 255, 255, 0.45),
          0 0.25rem 1rem rgba(15, 15, 20, 0.08);
      }
      .folder-export-card-body {
        background: rgba(255, 255, 255, 0.9);
        border-color: rgba(108, 117, 125, 0.35);
      }
      .folder-export-card input[type="checkbox"]:checked + .folder-export-card-body {
        background: rgba(25, 135, 84, 0.08);
      }
    }
  </style>

  <div class="row g-4">
    <div class="col-12 col-lg-7">
      <!-- Upload & Import -->
      <form id="import-form" class="card border-0 shadow-sm h-100" method="post" enctype="multipart/form-data" action="{{ url_for('views.import_csv') }}" data-hx-boost="false">
        <input type="hidden" name="import_action" id="importAction" value="confirm">
        <input type="hidden" name="import_async" value="1">
        <div class="card-header d-flex flex-wrap align-items-center justify-content-between gap-2">
          <div>
            <div class="fw-semibold">Import cards from a file</div>
            <div class="text-muted small">Upload a CSV/Excel export and choose how to apply it.</div>
          </div>
          <div class="btn-group btn-group-sm">
            <button type="button" id="btn-download-template-dragonshield" class="btn btn-outline-primary">
              DragonShield template
            </button>
            <button type="button" id="btn-download-template-manabox" class="btn btn-outline-primary">
              ManaBox template
            </button>
          </div>
        </div>
        <div class="card-body">
          <div class="alert alert-danger {% if not form_errors %}d-none{% endif %}" role="alert" id="importInlineAlert">
            <div class="fw-semibold">Import needs attention</div>
            <ul class="mb-0" id="importInlineErrors">
              {% for err in form_errors %}
                <li>{{ err }}</li>
              {% endfor %}
            </ul>
          </div>
          <div class="row g-3">
            <div class="col-12">
              <label for="file" class="form-label">Choose CSV or Excel file</label>
              <input class="form-control{% if field_errors.file %} is-invalid{% endif %}" type="file" id="file" name="file"
                     accept=".csv,.tsv,application/vnd.ms-excel,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                     {% if not preview %}required{% endif %}>
              <div class="invalid-feedback" id="fileError">{{ field_errors.file }}</div>
              <div class="form-text">
                Supports DragonShield exports and ManaBox binder exports. Files are limited to 10MB to keep imports fast and safe.
                ManaBox&#8217;s &#8220;Binder Name&#8221; maps to folders, and &#8220;Binder Type&#8221; switches between deck and collection buckets automatically.
                Use Preview &amp; map to confirm column assignments before you import.
              </div>
              {% if preview_filename %}
                <div class="form-text text-success">Using saved upload: {{ preview_filename }}</div>
                <input type="hidden" name="filepath" value="{{ filepath }}">
              {% endif %}
            </div>
            <div class="col-12">
              <label class="form-label">Import mode</label>
              <div class="form-check">
                <input class="form-check-input" type="radio" name="quantity_mode" id="mode-newonly" value="new_only"
                       {% if selected_mode == 'new_only' %}checked{% endif %}>
                <label class="form-check-label" for="mode-newonly">
                  Add new cards only — insert anything not already in your folders; leave existing counts alone.
                </label>
              </div>
              <div class="form-check">
                <input
                  class="form-check-input"
                  type="radio"
                  name="quantity_mode"
                  id="mode-purge"
                  value="purge"
                  {% if selected_mode == 'purge' %}checked{% endif %}
                  data-bs-toggle="collapse"
                  data-bs-target="#purge-warning"
                  aria-controls="purge-warning"
                  aria-expanded="{{ 'true' if selected_mode == 'purge' else 'false' }}"
                >
                <label class="form-check-label" for="mode-purge">
                  Clear &amp; import everything — wipe current cards first, then load this file as the source of truth.
                </label>
              </div>
              <div class="collapse {% if selected_mode == 'purge' %}show{% endif %}" id="purge-warning">
                <div class="form-text text-warning">
                  Warning: this deletes all existing cards before importing; only use when this file is your complete collection.
                </div>
              </div>
            </div>
          </div>

          <div class="d-flex flex-wrap align-items-center gap-2 mt-3">
            <button type="submit" class="btn btn-outline-secondary" id="btn-preview" data-import-action="preview">
              Preview &amp; map
            </button>
            <button type="submit" class="btn btn-primary btn-progress" id="btn-import" data-import-action="confirm">
              <span class="btn-progress__icon" aria-hidden="true">
                <i class="bi bi-upload btn-progress__idle"></i>
                <span class="spinner-border spinner-border-sm btn-progress__spinner" role="status"></span>
                <i class="bi bi-check2 btn-progress__check"></i>
              </span>
              <span class="btn-progress__label">Import</span>
            </button>
            <span class="text-muted small">Review Progress Below.</span>
          </div>
          <div class="mt-3 d-none" id="importProgress">
            <div class="d-flex align-items-center justify-content-between mb-1">
              <span class="small text-muted">Uploading &amp; processing your file...</span>
              <span class="small fw-semibold" id="importProgressLabel">Working</span>
            </div>
            <div class="progress progress-striped" role="progressbar" aria-label="Import progress" aria-valuemin="0" aria-valuemax="100">
              <div class="progress-bar progress-bar-striped progress-bar-animated" id="importProgressBar" style="width: 0%;" aria-valuenow="0"></div>
            </div>
            <div class="small text-muted mt-1">This may take a minute for larger binders. Please keep this tab open.</div>
            <div class="mt-2 d-flex flex-wrap align-items-center gap-2">
              <button type="button" class="btn btn-outline-danger btn-sm d-none" id="importRetry">
                Retry import
              </button>
              <span class="small text-muted d-none" id="importRetryHelp">We can retry this upload without reselecting the file.</span>
            </div>
          </div>
        </div>
        {% if preview %}
          <div class="card border-0 shadow-sm mt-3">
            <div class="card-header d-flex align-items-center gap-2">
              <i class="bi bi-eye"></i>
              <span>Preview &amp; column mapping</span>
            </div>
            <div class="card-body">
              <p class="text-muted small mb-3">
                Showing {{ preview.rows|length }} row{% if preview.rows|length != 1 %}s{% endif %}. Map columns to the required fields before importing.
              </p>
              {% if mapping_missing_labels or mapping_invalid %}
                <div class="alert alert-warning">
                  {% if mapping_missing_labels %}
                    Missing required mappings: {{ mapping_missing_labels | join(', ') }}.
                  {% endif %}
                  {% if mapping_invalid %}
                    Please fix invalid mappings before importing.
                  {% endif %}
                </div>
              {% endif %}
              <div class="row g-3">
                {% for spec in mapping_fields %}
                  {% set map_key = 'map_' ~ spec.key %}
                  <div class="col-12 col-md-6">
                    <label class="form-label" for="map-{{ spec.key }}">
                      {{ spec.label }}
                      {% if spec.required %}
                        <span class="text-danger">*</span>
                      {% endif %}
                    </label>
                    <select
                      class="form-select{% if field_errors.get(map_key) %} is-invalid{% endif %}"
                      name="map_{{ spec.key }}"
                      id="map-{{ spec.key }}"
                      data-map-field="{{ spec.key }}"
                    >
                      <option value="">-- Not mapped --</option>
                      {% for header in mapping_headers %}
                        <option value="{{ header }}" {% if mapping_selected.get(spec.key) == header %}selected{% endif %}>
                          {{ header }}
                        </option>
                      {% endfor %}
                    </select>
                    <div class="invalid-feedback" id="map-{{ spec.key }}-error">{{ field_errors.get(map_key) }}</div>
                    {% set accepted = mapping_expected.get(spec.key) %}
                    {% if accepted %}
                      <div class="form-text">Accepted: {{ accepted | join(', ') }}</div>
                    {% endif %}
                  </div>
                {% endfor %}
              </div>
              <div class="table-responsive mt-3">
                <table class="table table-sm table-striped align-middle">
                  <thead>
                    <tr>
                      {% for header in preview.headers %}
                        <th scope="col">{{ header }}</th>
                      {% endfor %}
                    </tr>
                  </thead>
                  <tbody>
                    {% for row in preview.rows[:8] %}
                      <tr>
                        {% for header in preview.headers %}
                          <td>{{ row.get(header) }}</td>
                        {% endfor %}
                      </tr>
                    {% endfor %}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        {% endif %}
      </form>
    </div>

    <div class="col-12 col-lg-5">
      <div class="d-flex flex-column gap-3">
        <div class="card border-0 shadow-sm">
          <div class="card-header d-flex align-items-center gap-2">
            <i class="bi bi-link-45deg"></i>
            <span>Import from a deck URL</span>
          </div>
          <div class="card-body">
            <p class="text-muted mb-3">
              Paste a public MTGGoldfish or Moxfield deck link and we’ll pull the list directly into a new deck folder.
            </p>
            <form class="row gy-3 gx-3 align-items-end" method="post" action="{{ url_for('views.create_proxy_deck') }}" id="proxyDeckImportForm">
              <div class="col-12">
                <label for="deck_url" class="form-label">Deck URL</label>
                <input type="url" class="form-control" id="deck_url" name="deck_url" placeholder="https://www.mtggoldfish.com/deck/1234 or https://moxfield.com/decks/ABC123" required>
              </div>
              <div class="col-12">
                <label for="deck_name" class="form-label">Deck name (optional)</label>
                <input type="text" class="form-control" id="deck_name" name="deck_name" placeholder="Use site name if blank">
              </div>
              <div class="col-12 d-grid">
                <button type="submit" class="btn btn-primary">Import deck</button>
              </div>
            </form>
          </div>
        </div>

        <div class="card border-0 shadow-sm">
          <div class="card-body d-flex flex-wrap align-items-center gap-3">
            <div class="icon-circle icon-circle-sm text-bg-info-subtle text-info">
              <i class="bi bi-magic"></i>
            </div>
            <div class="flex-grow-1">
              <h2 class="h6 mb-1">Only a few cards to log?</h2>
              <p class="text-muted small mb-0">
                The manual import wizard lets you paste a list and confirm the printing, finish, and folder for every card.
              </p>
            </div>
            <a class="btn btn-outline-primary" href="{{ url_for('views.manual_import') }}">
              Manual Import Wizard
            </a>
          </div>
        </div>

        {% if manual_seed %}
          <div class="card border-0 shadow-sm">
            <div class="card-body d-flex flex-column gap-3">
              <div class="d-flex align-items-start gap-2">
                <div class="icon-circle icon-circle-sm text-bg-warning-subtle text-warning">
                  <i class="bi bi-flag"></i>
                </div>
                <div>
                  <h2 class="h6 mb-1">Unmatched cards queue</h2>
                  <p class="text-muted small mb-2">
                    Paste any leftovers the importer couldn't resolve. We'll route them into the manual wizard so you can choose
                    the right set, finish, and folder later.
                  </p>
                </div>
              </div>
              <form class="row g-3" method="post" action="{{ url_for('views.manual_import') }}">
                <input type="hidden" name="action" value="parse">
                <div class="col-12">
                  <label for="unmatchedList" class="form-label">Unmatched items</label>
                  <textarea
                    id="unmatchedList"
                    name="card_list"
                    class="form-control"
                    rows="4"
                    placeholder="2 ??? Unknown Set&#10;3 Mystery Card"
                  ></textarea>
                  <div class="form-text">
                    One card per line; include a quantity like &ldquo;3 Card Name&rdquo; if known.
                  </div>
                </div>
                <div class="col-12 d-flex gap-2 align-items-center flex-wrap">
                  <button type="submit" class="btn btn-warning">
                    Send to manual queue
                  </button>
                  <span class="text-muted small">We will prompt you to confirm set, language, foil, and folder.</span>
                </div>
              </form>
            </div>
          </div>
        {% endif %}
      </div>
    </div>
  </div>

  <div class="card border-0 shadow-sm mt-4">
    {% if folder_export_options %}
      <form
        method="get"
        action="{{ url_for('views.export_cards') }}"
        class="card-body d-flex flex-column gap-3"
        data-hx-boost="false"
        id="folderExportForm">
        <div>
          <div class="d-flex align-items-center gap-2 mb-2">
            <i class="bi bi-box-arrow-down text-success"></i>
            <h2 class="h5 mb-0">Export collection</h2>
          </div>
          <p class="text-muted small mb-0">
            Download a CSV snapshot of your folders for backups, trades, or other trackers.
          </p>
        </div>
        <div class="form-check form-switch mb-0">
          <input
            class="form-check-input"
            type="checkbox"
            role="switch"
            id="folderExportAll"
            name="all_folders"
            value="1"
            checked>
          <label class="form-check-label fw-semibold" for="folderExportAll">
            Export every folder
          </label>
          <div class="form-text" id="folderExportStatus">
            All of your folders will be exported.
          </div>
        </div>
        <div class="folder-export-surface">
          <p class="text-muted small mb-3">
            Uncheck the toggle above to pick specific folders.
          </p>
          <div class="folder-export-grid">
            {% for folder in folder_export_options %}
              <label class="folder-export-card">
                <input
                  type="checkbox"
                  value="{{ folder.id }}"
                  id="folderExport{{ folder.id }}"
                  name="folder_ids"
                  data-folder-checkbox>
                <div class="folder-export-card-body">
                  <div class="fw-semibold">{{ folder.name }}</div>
                  <div class="text-muted small">
                    {{ folder.category_label }}{% if folder.is_proxy %} &middot; Proxy{% endif %}{% if folder.is_public %} &middot; Shared{% endif %}
                  </div>
                </div>
              </label>
            {% endfor %}
          </div>
        </div>
        <div>
          <label class="form-label">Export format</label>
          <div class="dropdown dv-select w-100" data-dv-select="folder-export-format">
            {% set default_format = export_format_options[0] if export_format_options else {'value': '', 'label': 'Standard CSV', 'description': 'Includes folder name, quantity, set code, collector number, language, and foil status.'} %}
            <input type="hidden" name="format" data-dv-select-input value="{{ default_format.value }}">
            <button
              class="btn dv-select-toggle w-100 justify-content-between"
              type="button"
              id="folderExportFormatToggle"
              data-bs-toggle="dropdown"
              aria-expanded="false">
              <span data-dv-select-label>{{ default_format.label }}</span>
              <i class="bi bi-chevron-down"></i>
            </button>
            <ul class="dropdown-menu dv-select-menu w-100" aria-labelledby="folderExportFormatToggle">
              {% for option in export_format_options %}
                <li>
                  <button
                    class="dropdown-item {% if loop.first %}active{% endif %}"
                    type="button"
                    data-dv-select-option
                    data-value="{{ option.value }}"
                    data-label="{{ option.label }}"
                    data-description="{{ option.description }}">
                    <div class="fw-semibold">{{ option.label }}</div>
                    <div class="small text-muted">{{ option.description }}</div>
                  </button>
                </li>
              {% endfor %}
            </ul>
          </div>
          <div class="form-text" id="folderExportFormatHelp">
            {{ default_format.description }}
          </div>
        </div>
        <div class="mt-auto d-grid">
          <button class="btn btn-success" type="submit" id="folderExportSubmit">
            Download export
          </button>
        </div>
      </form>
    {% else %}
      <div class="card-body d-flex flex-column gap-3">
        <div>
          <div class="d-flex align-items-center gap-2 mb-2">
            <i class="bi bi-box-arrow-down text-success"></i>
            <h2 class="h5 mb-0">Export collection</h2>
          </div>
          <p class="text-muted small mb-0">
            Create a folder first, then come back to generate CSV exports.
          </p>
        </div>
        <div class="alert alert-info mb-0">
          You don't have any folders linked to your account yet.
        </div>
        <div class="mt-auto d-grid">
          <a class="btn btn-outline-primary" href="{{ url_for('views.manage_folder_preferences') }}">
            Create folders
          </a>
        </div>
      </div>
    {% endif %}
  </div>
</div>

{% set import_success = request.args.get('import_success') %}
{% if folder_export_options %}
<div class="modal fade" id="postImportFolderModal" tabindex="-1" aria-labelledby="postImportFolderLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <div>
          <h5 class="modal-title" id="postImportFolderLabel">Confirm folder types</h5>
          <p class="small text-muted mb-0">Mark each folder as a deck or collection to keep stats accurate.</p>
        </div>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="alert alert-info small">
          Choose <strong>Deck</strong> for playable decks or <strong>Collection</strong> for inventory/bulk.
        </div>
        <div class="table-responsive">
          <table class="table table-sm align-middle mb-0">
            <thead>
              <tr>
                <th>Name</th>
                <th style="width:260px;">Category</th>
                <th class="text-center" style="width:100px;">Proxy</th>
              </tr>
            </thead>
            <tbody>
              {% for folder in folder_export_options %}
              <tr data-folder-row data-folder-id="{{ folder.id }}">
                <td class="fw-semibold">{{ folder.name }}</td>
                <td>
                  <div class="d-flex flex-wrap gap-3">
                    <div class="form-check">
                      <input class="form-check-input" type="radio" name="cat-{{ folder.id }}" id="cat-{{ folder.id }}-deck" value="{{ deck_category }}" {% if folder.is_deck %}checked{% endif %}>
                      <label class="form-check-label" for="cat-{{ folder.id }}-deck">Deck</label>
                    </div>
                    <div class="form-check">
                      <input class="form-check-input" type="radio" name="cat-{{ folder.id }}" id="cat-{{ folder.id }}-collection" value="{{ collection_category }}" {% if folder.is_collection %}checked{% endif %}>
                      <label class="form-check-label" for="cat-{{ folder.id }}-collection">Collection</label>
                    </div>
                  </div>
                </td>
                <td class="text-center">
                  <span class="badge {% if folder.is_proxy %}text-bg-warning text-dark{% else %}text-bg-secondary{% endif %}">
                    {% if folder.is_proxy %}Proxy{% else %}Owned{% endif %}
                  </span>
                </td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
      <div class="modal-footer">
        <div class="me-auto small text-muted" id="postImportFolderStatus"></div>
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Skip</button>
        <button type="button" class="btn btn-primary" id="postImportFolderSave">Save</button>
      </div>
    </div>
  </div>
</div>
{% endif %}

<script>
  (function () {
    const form = document.getElementById("import-form");
    const btn = document.getElementById("btn-import");
    const actionInput = document.getElementById("importAction");
    const STORAGE_KEY = "dv-import-job";
    const COMPLETE_KEY = "dv-import-complete-url";
    const progressWrap = document.getElementById("importProgress");
    const progressLabel = document.getElementById("importProgressLabel");
    const progressBar = document.getElementById("importProgressBar");
    const summaryAlert = document.getElementById("importSummaryAlert");
    const summaryTitle = document.getElementById("importSummaryTitle");
    const summaryDetails = document.getElementById("importSummaryDetails");
    const inlineAlert = document.getElementById("importInlineAlert");
    const inlineErrors = document.getElementById("importInlineErrors");
    const retryBtn = document.getElementById("importRetry");
    const retryHelp = document.getElementById("importRetryHelp");
    const statusEndpoint = "{{ url_for('views.import_status') }}";
    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content || "";
    const STATS_KEY = "dv-import-stats";
    const FOLDER_MODAL_KEY = "dv-import-show-folders";
    let pollTimer = null;
    let activeJobId = null;
    let submitLocked = false;
    let completeUrl = "";
    let redirectPending = false;

    function updateProgress(value) {
      if (!progressBar) return;
      const clamped = Math.max(0, Math.min(100, value));
      progressBar.style.width = `${clamped}%`;
      progressBar.setAttribute("aria-valuenow", String(Math.round(clamped)));
    }

    function setBarAnimated(animated) {
      if (!progressBar) return;
      progressBar.classList.toggle("progress-bar-animated", animated);
      progressBar.classList.toggle("progress-bar-striped", animated);
    }

    function setProgressText(text) {
      if (progressLabel) progressLabel.textContent = text || "";
    }

    function clearInlineErrors() {
      if (inlineAlert) {
        inlineAlert.classList.add("d-none");
      }
      if (inlineErrors) {
        inlineErrors.innerHTML = "";
      }
      const invalids = form ? form.querySelectorAll(".is-invalid") : [];
      invalids.forEach((el) => el.classList.remove("is-invalid"));
      const feedbacks = form ? form.querySelectorAll(".invalid-feedback") : [];
      feedbacks.forEach((el) => {
        if (el.id && el.id.endsWith("-error")) {
          el.textContent = "";
        }
      });
      const fileError = document.getElementById("fileError");
      if (fileError) fileError.textContent = "";
    }

    function applyInlineErrors(message, fieldErrors) {
      const messages = [];
      if (message) {
        messages.push(message);
      }
      if (fieldErrors) {
        Object.values(fieldErrors).forEach((msg) => {
          if (msg && !messages.includes(msg)) messages.push(msg);
        });
      }
      if (inlineErrors) {
        inlineErrors.innerHTML = "";
        messages.forEach((msg) => {
          const li = document.createElement("li");
          li.textContent = msg;
          inlineErrors.appendChild(li);
        });
      }
      if (inlineAlert) {
        inlineAlert.classList.remove("d-none");
      }
      if (fieldErrors && form) {
        Object.entries(fieldErrors).forEach(([key, msg]) => {
          if (!key) return;
          if (key === "file") {
            const fileInput = document.getElementById("file");
            if (fileInput) fileInput.classList.add("is-invalid");
            const fileError = document.getElementById("fileError");
            if (fileError) fileError.textContent = msg || "";
            return;
          }
          const field = form.querySelector(`[name="${key}"]`);
          if (field) {
            field.classList.add("is-invalid");
            const errorEl = document.getElementById(`${key.replace(/_/g, "-")}-error`) || document.getElementById(`${field.id}-error`);
            if (errorEl) {
              errorEl.textContent = msg || "";
            }
          }
        });
      }
    }

    function renderCompletionSummary(summary) {
      if (!summaryAlert || !summaryDetails) return;
      const added = Number(summary.added || 0);
      const updated = Number(summary.updated || 0);
      const skipped = Number(summary.skipped || 0);
      const errors = Number(summary.errors || 0);
      const file = String(summary.file || "").trim();
      const processed = Number(summary.processed || 0);
      const total = Number(summary.total_rows || summary.total || 0);
      const parts = [`${added} added`, `${updated} updated`, `${skipped} skipped`];
      if (errors) {
        parts.push(`${errors} error${errors === 1 ? "" : "s"}`);
      }
      if (processed && total) {
        parts.push(`${processed} / ${total} rows`);
      }
      const prefix = file ? `File: ${file}. ` : "";
      summaryDetails.textContent = `${prefix}${parts.join(", ")}.`;
      if (summaryTitle) {
        summaryTitle.textContent = errors ? "Import completed with errors" : "Import completed";
      }
      summaryAlert.classList.remove("d-none", "alert-success", "alert-warning");
      summaryAlert.classList.add(errors ? "alert-warning" : "alert-success");
    }

    function setBtnState(state) {
      if (!btn) return;
      btn.classList.remove("is-loading", "is-complete");
      btn.disabled = false;
      if (retryBtn) retryBtn.classList.add("d-none");
      if (retryHelp) retryHelp.classList.add("d-none");
      if (state === "loading") {
        btn.classList.add("is-loading");
        btn.disabled = true;
      } else if (state === "complete") {
        btn.classList.add("is-complete");
      }
      if (progressWrap) {
        if (state === "loading") {
          progressWrap.classList.remove("d-none");
          setProgressText("Uploading");
          setBarAnimated(true);
        } else if (state === "complete") {
          progressWrap.classList.remove("d-none");
          setBarAnimated(false);
        } else {
          progressWrap.classList.add("d-none");
          setBarAnimated(false);
          updateProgress(0);
        }
      }
    }

    function applyEvent(event) {
      if (!event) return false;
      const type = event.type || "";
      if (type === "queued") {
        setBtnState("loading");
        setProgressText("Queued");
        updateProgress(0);
        return false;
      }
      if (type === "started") {
        setBtnState("loading");
        setProgressText("Starting import");
        updateProgress(0);
        return false;
      }
      if (type === "progress") {
        const processed = Number(event.processed || 0);
        const total = Number(event.total_rows || event.total || event.stats?.total_rows || 0);
        const pct = total > 0 ? Math.min(Math.round((processed / total) * 100), 99) : 0;
        updateProgress(pct);
        setProgressText(total > 0 ? `${pct}% · ${processed} / ${total}` : `${processed} rows`);
        return false;
      }
      if (type === "completed") {
        updateProgress(100);
        setBtnState("complete");
        const stats = event.stats || {};
        const added = Number(stats.added ?? event.added ?? 0);
        const updated = Number(stats.updated ?? event.updated ?? 0);
        const skipped = Number(stats.skipped ?? event.skipped ?? 0);
        const errors = Number(stats.errors ?? event.errors ?? 0);
        const detail = `Done · ${added} added, ${updated} updated, ${skipped} skipped`;
        setProgressText(detail);
        const summaryPayload = {
          added,
          updated,
          skipped,
          errors,
          processed: event.processed || stats.processed || 0,
          total_rows: event.total_rows || event.total || stats.total_rows || 0,
          file: event.file || "",
        };
        try {
          sessionStorage.setItem(STATS_KEY, JSON.stringify(summaryPayload));
          sessionStorage.setItem(FOLDER_MODAL_KEY, "1");
        } catch (e) {}
        renderCompletionSummary(summaryPayload);
        if (!completeUrl) {
          try {
            const url = new URL(window.location.href);
            url.searchParams.set("import_success", "1");
            completeUrl = url.toString();
          } catch (e) {}
        }
        if (!completeUrl && typeof window.showPostImportFolderModal === "function") {
          window.showPostImportFolderModal();
        }
        if (completeUrl && !redirectPending) {
          redirectPending = true;
          setProgressText("Finalizing...");
          window.setTimeout(() => {
            window.location.assign(completeUrl);
          }, 600);
        }
        return true;
      }
      if (type === "failed") {
        setBtnState("idle");
        if (progressWrap) {
          progressWrap.classList.remove("d-none");
        }
        setBarAnimated(false);
        updateProgress(0);
        setProgressText(event.error || "Import failed");
        if (retryBtn) {
          retryBtn.classList.remove("d-none");
        }
        if (retryHelp) {
          retryHelp.classList.remove("d-none");
        }
        applyInlineErrors(event.error || "Import failed", null);
        return true;
      }
      return false;
    }

    function stopPolling({ clearStorage } = { clearStorage: true }) {
      if (pollTimer) {
        window.clearTimeout(pollTimer);
        pollTimer = null;
      }
      if (clearStorage) {
        sessionStorage.removeItem(STORAGE_KEY);
        sessionStorage.removeItem(COMPLETE_KEY);
        activeJobId = null;
      }
    }

    function pollStatus() {
      if (!activeJobId) return;
      const url = `${statusEndpoint}?job_id=${encodeURIComponent(activeJobId)}`;
      fetch(url, { headers: { Accept: "application/json" } })
        .then((resp) => {
          if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
          return resp.json();
        })
        .then((data) => {
          const events = Array.isArray(data.events) ? data.events : [];
          if (!events.length) {
            pollTimer = window.setTimeout(pollStatus, 1500);
            return;
          }
          const latest = events[events.length - 1];
          const done = applyEvent(latest);
          if (done) {
            stopPolling();
            submitLocked = false;
            return;
          }
          pollTimer = window.setTimeout(pollStatus, 1500);
        })
        .catch(() => {
          pollTimer = window.setTimeout(pollStatus, 2500);
        });
    }

    function startPolling(jobId) {
      if (!jobId) return;
      activeJobId = jobId;
      sessionStorage.setItem(STORAGE_KEY, jobId);
      if (!completeUrl) {
        completeUrl = sessionStorage.getItem(COMPLETE_KEY) || "";
      }
      setBtnState("loading");
      setProgressText("Queued");
      updateProgress(0);
      pollStatus();
    }

    function handleRetry() {
      if (!form || !retryBtn) return;
      clearInlineErrors();
      retryBtn.disabled = true;
      setBtnState("loading");
      setProgressText("Retrying");
      updateProgress(0);
      const formData = new FormData();
      formData.set("import_action", "retry");
      if (activeJobId) {
        formData.set("job_id", activeJobId);
      }
      const actionUrl = form.getAttribute("action") || (typeof form.action === "string" ? form.action : "");
      fetch(actionUrl || window.location.href, {
        method: "POST",
        body: formData,
        headers: {
          Accept: "application/json",
          "X-Requested-With": "XMLHttpRequest",
          ...(csrfToken ? { "X-CSRFToken": csrfToken } : {}),
        },
      })
        .then((resp) =>
          resp
            .json()
            .then((data) => ({ ok: resp.ok, status: resp.status, data }))
            .catch(() => ({ ok: false, status: resp.status, data: {} }))
        )
        .then(({ ok, data }) => {
          if (!ok || !data || data.ok === false) {
            applyInlineErrors(data?.error || "Retry failed to start.", data?.field_errors || {});
            throw new Error(data?.error || "Retry failed to start.");
          }
          completeUrl = data.complete_url || "";
          if (completeUrl) {
            sessionStorage.setItem(COMPLETE_KEY, completeUrl);
          } else {
            sessionStorage.removeItem(COMPLETE_KEY);
          }
          startPolling(data.job_id);
        })
        .catch((err) => {
          setBtnState("idle");
          if (progressWrap) {
            progressWrap.classList.remove("d-none");
          }
          setBarAnimated(false);
          updateProgress(0);
          setProgressText(err.message || "Retry failed to start.");
          retryBtn.disabled = false;
        });
    }

    function handleAsyncSubmit(event) {
      const submitter = event?.submitter;
      const requestedAction = submitter?.dataset?.importAction || actionInput?.value || "confirm";
      if (actionInput) {
        actionInput.value = requestedAction;
      }
      if (requestedAction === "preview") {
        return;
      }
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
      if (!form || !btn) return;
      if (!window.fetch || !window.FormData) {
        setBtnState("idle");
        if (progressWrap) {
          progressWrap.classList.remove("d-none");
        }
        setBarAnimated(false);
        updateProgress(0);
        setProgressText("Browser upload support missing.");
        return;
      }
      clearInlineErrors();
      if (submitLocked) {
        setProgressText("Import already running...");
        return;
      }
      if (!form.checkValidity()) {
        form.reportValidity();
        return;
      }
      submitLocked = true;
      setBtnState("loading");
      setProgressText("Uploading");
      updateProgress(0);

      const formData = new FormData(form);
      const actionUrl = form.getAttribute("action") || (typeof form.action === "string" ? form.action : "");
      fetch(actionUrl || window.location.href, {
        method: "POST",
        body: formData,
        headers: {
          Accept: "application/json",
          "X-Requested-With": "XMLHttpRequest",
          ...(csrfToken ? { "X-CSRFToken": csrfToken } : {}),
        },
      })
        .then((resp) =>
          resp
            .json()
            .then((data) => ({ ok: resp.ok, status: resp.status, data }))
            .catch(() => ({ ok: false, status: resp.status, data: {} }))
        )
        .then(({ ok, data }) => {
          if (!ok || !data || data.ok === false) {
            applyInlineErrors(data?.error || "Import failed to start.", data?.field_errors || {});
            throw new Error(data?.error || "Import failed to start.");
          }
          completeUrl = data.complete_url || "";
          if (completeUrl) {
            sessionStorage.setItem(COMPLETE_KEY, completeUrl);
          } else {
            sessionStorage.removeItem(COMPLETE_KEY);
          }
          startPolling(data.job_id);
        })
        .catch((err) => {
          setBtnState("idle");
          if (progressWrap) {
            progressWrap.classList.remove("d-none");
          }
          setBarAnimated(false);
          updateProgress(0);
          setProgressText(err.message || "Import failed to start.");
          applyInlineErrors(err.message || "Import failed to start.", null);
          submitLocked = false;
        });
    }

    if (form && btn) {
      form.addEventListener("submit", handleAsyncSubmit, true);
    }
    if (retryBtn) {
      retryBtn.addEventListener("click", handleRetry);
    }

    const storedSummary = sessionStorage.getItem(STATS_KEY);
    if (storedSummary) {
      sessionStorage.removeItem(STATS_KEY);
      try {
        renderCompletionSummary(JSON.parse(storedSummary));
      } catch (e) {}
    }

    const existingJob = sessionStorage.getItem(STORAGE_KEY);
    if (existingJob) {
      completeUrl = sessionStorage.getItem(COMPLETE_KEY) || "";
      startPolling(existingJob);
    }

    // Escapes a CSV field per RFC 4180
    function csvField(v) {
      const s = String(v ?? '');
      return /[",\r\n]/.test(s) ? `"${s.replace(/"/g, '""')}"` : s;
    }

    function downloadTemplate(headers, filename) {
      const line = headers.map(csvField).join(',');
      const csv = "\uFEFF" + line + "\r\n";

      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1500);
    }

    const templates = [
      {
        id: "btn-download-template-dragonshield",
        filename: "dragonsvault-import-template.csv",
        headers: [
          "Folder Name",
          "Quantity",
          "Trade Quantity",
          "Card Name",
          "Set Code",
          "Set Name",
          "Card Number",
          "Condition",
          "Printing",
          "Language",
          "Price Bought",
          "Date Bought",
          "LOW",
          "MID",
          "MARKET"
        ]
      },
      {
        id: "btn-download-template-manabox",
        filename: "manabox-import-template.csv",
        headers: [
          "Binder Name",
          "Binder Type",
          "Name",
          "Set code",
          "Set name",
          "Collector number",
          "Foil",
          "Rarity",
          "Quantity",
          "ManaBox ID",
          "Scryfall ID",
          "Purchase price",
          "Misprint",
          "Altered",
          "Condition",
          "Language",
          "Purchase price currency"
        ]
      }
    ];

    templates.forEach(({ id, filename, headers }) => {
      const btn = document.getElementById(id);
      if (!btn) return;
      btn.addEventListener("click", function () {
        downloadTemplate(headers, filename);
      });
    });

    const exportToggle = document.getElementById("folderExportAll");
    const exportStatus = document.getElementById("folderExportStatus");
    const exportSubmit = document.getElementById("folderExportSubmit");
    const exportFormatWrapper = document.querySelector('[data-dv-select="folder-export-format"]');
    const exportFormatHelp = document.getElementById("folderExportFormatHelp");
    const exportCheckboxes = Array.from(document.querySelectorAll("[data-folder-checkbox]"));

    function updateExportState() {
      if (!exportSubmit) return;
      const useAll = exportToggle?.checked ?? true;
      let selected = 0;
      exportCheckboxes.forEach((cb) => {
        cb.disabled = useAll;
        if (useAll) {
          cb.checked = false;
        } else if (cb.checked) {
          selected += 1;
        }
      });

      if (exportStatus) {
        if (useAll) {
          exportStatus.textContent = "All of your folders will be exported.";
        } else if (selected) {
          exportStatus.textContent = selected === 1 ? "1 folder selected." : `${selected} folders selected.`;
        } else {
          exportStatus.textContent = "Choose at least one folder to continue.";
        }
      }

      exportSubmit.disabled = !exportCheckboxes.length || (!useAll && selected === 0);
    }

    function updateFormatHelp(value) {
      if (!exportFormatWrapper || !exportFormatHelp) return;
      const options = Array.from(exportFormatWrapper.querySelectorAll("[data-dv-select-option]"));
      const matchValue = value ?? "";
      const button = options.find((btn) => (btn.dataset.value ?? "") === matchValue) || options[0];
      if (button) {
        exportFormatHelp.textContent = button.dataset.description || "";
      }
    }

    if (exportToggle) {
      exportToggle.addEventListener("change", updateExportState);
      updateExportState();
    }
    exportCheckboxes.forEach((cb) => cb.addEventListener("change", updateExportState));
    if (exportFormatWrapper) {
      const formatInput = exportFormatWrapper.querySelector("[data-dv-select-input]");
      if (formatInput) {
        updateFormatHelp(formatInput.value || "");
        exportFormatWrapper.addEventListener("dv-select:change", (event) => {
          updateFormatHelp(event.detail?.value ?? formatInput.value ?? "");
        });
        exportFormatWrapper.addEventListener("dv-select:ready", (event) => {
          updateFormatHelp(event.detail?.value ?? formatInput.value ?? "");
        });
      }
    }
  })();
</script>

{% if folder_export_options %}
<script>
(function(){
  const modalEl = document.getElementById('postImportFolderModal');
  if (!modalEl) return;
  let modal = null;
  const saveBtn = document.getElementById('postImportFolderSave');
  const statusEl = document.getElementById('postImportFolderStatus');
  const csrfToken = window.csrfToken || document.querySelector('meta[name="csrf-token"]')?.content || '';

  function setStatus(msg, variant){
    if (!statusEl) return;
    statusEl.textContent = msg || '';
    statusEl.className = 'me-auto small';
    if (variant) statusEl.classList.add('text-' + variant);
    else statusEl.classList.add('text-muted');
  }

  function ensureModal(){
    if (!window.bootstrap) return null;
    if (!modal) {
      modal = bootstrap.Modal.getOrCreateInstance(modalEl);
    }
    return modal;
  }

  function wantsShow(){
    return {{ 'true' if import_success else 'false' }} || sessionStorage.getItem('dv-import-show-folders') === '1';
  }

  function requestShow(){
    if (!wantsShow()) return;
    const inst = ensureModal();
    if (inst) {
      sessionStorage.removeItem('dv-import-show-folders');
      inst.show();
      return;
    }
    window.addEventListener('load', () => {
      if (wantsShow()) {
        const delayed = ensureModal();
        if (delayed) {
          sessionStorage.removeItem('dv-import-show-folders');
          delayed.show();
        }
      }
    }, { once: true });
  }

  async function handleSave(){
    const rows = Array.from(modalEl.querySelectorAll('[data-folder-row]'));
    const payload = rows.map((row) => {
      const id = row.dataset.folderId;
      const selected = row.querySelector('input[type="radio"]:checked');
      return { id, category: selected ? selected.value : '{{ deck_category }}' };
    }).filter(entry => entry.id);
    setStatus('Saving…', 'muted');
    if (saveBtn) saveBtn.disabled = true;
    try {
      const resp = await fetch('{{ url_for("views.api_update_folder_categories") }}', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(csrfToken ? {'X-CSRFToken': csrfToken} : {}),
        },
        body: JSON.stringify({ folders: payload }),
      });
      const data = await resp.json().catch(() => ({}));
      if (!resp.ok || data.ok === false){
        throw new Error(data.error || 'Unable to save folder categories.');
      }
      setStatus(`Saved ${data.updated || 0} folder categories.`, 'success');
      const inst = ensureModal();
      if (inst) {
        setTimeout(() => inst.hide(), 600);
      }
    } catch (err){
      setStatus(err.message || 'Unable to save folder categories.', 'danger');
    } finally {
      if (saveBtn) saveBtn.disabled = false;
    }
  }

  if (saveBtn) saveBtn.addEventListener('click', handleSave);
  window.showPostImportFolderModal = requestShow;
  requestShow();
})();
</script>
{% endif %}

<script>
  (function () {
    const form = document.getElementById("proxyDeckImportForm");
    if (!form) return;
    const submitBtn = form.querySelector('button[type="submit"]');
    form.addEventListener("submit", (event) => {
      if (form.dataset.submitting === "1") {
        event.preventDefault();
        return;
      }
      form.dataset.submitting = "1";
      if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.textContent = "Importing...";
      }
    });
  })();
</script>

{% endblock %}
