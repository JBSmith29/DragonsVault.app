{% extends "base.html" %}
{% block title %}Opening Hand - DragonsVault{% endblock %}

{% block content %}

<style>
  #main {
    overflow-y: auto;
    overflow-x: hidden;
    padding-bottom: 0;
    margin-top: 0;
  }
  .opening-hand-stage {
    min-height: 100%;
    display: flex;
    flex-direction: column;
    gap: 0.65rem;
    --hand-actions-safe: env(safe-area-inset-bottom, 0px);
    padding-bottom: calc(var(--hand-actions-space, 0px) + var(--hand-actions-safe));
  }
  .opening-hand-stage.compact-mode .opening-hand-header {
    display: none;
  }
  .opening-hand-stage.compact-mode .opening-hand-board .card-body > .d-flex {
    margin-bottom: 0.35rem !important;
  }
  .opening-hand-stage.compact-mode .opening-hand-board .card-body > .d-flex > div:first-child {
    display: none;
  }
  .opening-hand-header {
    flex: 0 0 auto;
    margin: 0;
  }
  .opening-hand-board {
    flex: 1 1 auto;
    min-height: 240px;
  }
  .opening-hand-board .card-body {
    height: 100%;
    display: flex;
    flex-direction: column;
    overflow: visible;
  }
  .opening-hand-board .board-grid-layout {
    flex: 1 1 auto;
    overflow: visible;
    padding-right: 0.25rem;
  }
  .opening-hand-board .board-note {
    font-size: 0.78rem;
  }
  .opening-hand-layout {
    flex: 0 0 auto;
    min-height: 0;
    display: grid;
    gap: 0.75rem;
    grid-template-columns: minmax(0, 280px) minmax(0, 1fr);
    align-items: start;
  }
  .opening-hand-layout.full-mode {
    grid-template-columns: 1fr;
  }
  @media (max-width: 992px) {
    .opening-hand-layout {
      grid-template-columns: 1fr;
    }
  }
  .opening-hand-layout > section {
    min-height: 0;
  }
  .opening-hand-hand-wrapper {
    display: flex;
    flex-direction: column;
    min-height: 0;
  }
  .opening-hand-hand-wrapper .opening-hand-hand {
    flex: 0 0 auto;
  }
  #deckSourceCard {
    height: 100%;
  }
  .opening-hand-hand {
    height: auto;
  }
  #deckSourceCard .card-body {
    height: 100%;
    display: flex;
    flex-direction: column;
    gap: 0.6rem;
  }
  .opening-hand-hand .card-body {
    height: auto;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    position: relative;
  }
  .hand-status {
    order: 1;
  }
  .hand-card-grid {
    flex: 1 1 auto;
    min-height: 0;
    display: flex;
    align-items: flex-end;
    justify-content: center;
    gap: 0;
    padding: 0.6rem 1.35rem 1rem;
    overflow-x: auto;
    overflow-y: hidden;
    scroll-snap-type: x mandatory;
    order: 2;
  }
  .hand-card-grid > .text-muted {
    margin: auto;
  }
  .hand-card {
    background: rgba(15, 23, 42, 0.45);
    border: 1px solid rgba(148, 163, 184, 0.12);
    border-radius: 1rem;
    padding: 0.4rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    position: relative;
    cursor: pointer;
    box-shadow: 0 0.6rem 1.4rem rgba(15, 23, 42, 0.28);
    --hand-rotate: 0deg;
    --hand-offset: 0px;
    transition:
      border-color 0.16s ease-out,
      transform 0.16s ease-out,
      box-shadow 0.16s ease-out;
    width: 100%;
    max-width: 180px;
    transform: translateY(var(--hand-offset)) rotate(var(--hand-rotate));
    transform-origin: bottom center;
  }
  .hand-card .card-flip-btn {
    position: absolute;
    bottom: -0.55rem;
    left: 50%;
    transform: translateX(-50%);
    z-index: 6;
    border: 1px solid rgba(148, 163, 184, 0.3);
    background: rgba(15, 23, 42, 0.75);
    color: #fff;
    border-radius: 999px;
    padding: 0.18rem 0.6rem;
    font-size: 0.65rem;
    line-height: 1;
  }
  .hand-card.has-back {
    padding-bottom: 0.9rem;
  }
  .hand-card .card-flip-btn:hover,
  .hand-card .card-flip-btn:focus-visible {
    background: rgba(15, 23, 42, 0.9);
  }
  .hand-card-grid .hand-card {
    width: clamp(120px, 16vw, 190px);
    max-width: none;
    flex: 0 0 auto;
    margin-left: -24px;
    scroll-snap-align: center;
  }
  .hand-card-grid .hand-card:first-child {
    margin-left: 0;
  }
  .hand-card-grid .hand-card:nth-child(1) { --hand-rotate: -3.5deg; --hand-offset: 6px; }
  .hand-card-grid .hand-card:nth-child(2) { --hand-rotate: -2deg; --hand-offset: 3px; }
  .hand-card-grid .hand-card:nth-child(3) { --hand-rotate: -1deg; --hand-offset: 2px; }
  .hand-card-grid .hand-card:nth-child(4) { --hand-rotate: 0deg; --hand-offset: 0px; }
  .hand-card-grid .hand-card:nth-child(5) { --hand-rotate: 1deg; --hand-offset: 2px; }
  .hand-card-grid .hand-card:nth-child(6) { --hand-rotate: 2deg; --hand-offset: 3px; }
  .hand-card-grid .hand-card:nth-child(7) { --hand-rotate: 3.5deg; --hand-offset: 6px; }
  .hand-card:not(.card-tapped):hover {
    border-color: rgba(148, 180, 255, 0.45);
    transform: translateY(calc(var(--hand-offset) - 8px)) rotate(var(--hand-rotate)) scale(1.08);
    box-shadow: 0 1.2rem 2.6rem rgba(15, 23, 42, 0.4);
    z-index: 2;
  }
  .hand-card:not(.card-tapped):active {
    transform: translateY(calc(var(--hand-offset) - 2px)) rotate(var(--hand-rotate)) scale(0.98);
    box-shadow: 0 0.4rem 1rem rgba(15, 23, 42, 0.28);
  }
  .hand-card img {
    width: 100%;
    aspect-ratio: 0.718;
    border-radius: 0.75rem;
    box-shadow: 0 1.25rem 2.2rem rgba(15, 23, 42, 0.3);
    object-fit: contain;
    background: radial-gradient(circle at 30% 20%, rgba(148, 180, 255, 0.18), transparent),
      rgba(15, 23, 42, 0.85);
    transition: transform 0.2s ease-out;
  }
  .hand-card .name {
    display: none;
  }
  .hand-card.card-tapped {
    border-color: rgba(250, 204, 21, 0.65);
    background: rgba(250, 204, 21, 0.08);
    transform-origin: center center;
    transform: rotate(90deg);
    margin-right: 1.25rem;
    margin-bottom: 0;
  }
  .hand-card.card-tapped:hover {
    transform: rotate(90deg);
  }
  .card-art {
    display: block;
  }
  .card-annotation {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    background: rgba(15, 23, 42, 0.72);
    border: 1px solid rgba(148, 163, 184, 0.3);
    border-radius: 0.6rem;
    padding: 0.2rem 0.5rem;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: rgba(226, 232, 240, 0.92);
    pointer-events: none;
  }
  .draw-empty,
  .board-empty {
    grid-column: 1 / -1;
    text-align: center;
    color: var(--bs-secondary-color);
  }
  .board-grid-layout {
    display: grid;
    grid-template-areas:
      "creatures commandColumn"
      "permanents commandColumn"
      "lands commandColumn";
    grid-template-columns: minmax(0, 1fr) minmax(260px, 340px);
    column-gap: 1.25rem;
    row-gap: 1.25rem;
    align-items: start;
  }
  .board-column-command {
    grid-area: commandColumn;
    display: grid;
    gap: 0;
    align-content: start;
  }
  .board-zone {
    background: transparent;
    border: none;
    border-radius: 0.85rem;
    padding: 0.85rem 0.65rem;
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    min-height: 200px;
  }
  .board-zone[hidden] {
    display: none;
  }
  .board-zone-header {
    font-size: 0.72rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--bs-secondary-color);
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }
  .board-zone-header::after {
    content: "";
    flex: 1 1 auto;
    height: 1px;
    background: rgba(148, 163, 184, 0.22);
  }
  .board-zone-cards {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    align-items: flex-start;
    min-height: 180px;
  }
  .board-zone-graveyard {
    background: rgba(15, 23, 42, 0.35);
    border: 1px solid rgba(148, 163, 184, 0.18);
    border-radius: 0.95rem;
    padding: 0.85rem 0.75rem;
    min-height: 240px;
  }
  .board-zone-graveyard .board-zone-header {
    gap: 0.65rem;
  }
  .board-zone-graveyard .board-zone-header::after {
    opacity: 0.5;
  }
  .board-zone-graveyard-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
    gap: 0.65rem;
    align-content: start;
    max-height: 280px;
    overflow-y: auto;
    padding-right: 0.2rem;
  }
  .board-zone-graveyard-grid::-webkit-scrollbar {
    width: 6px;
  }
  .board-zone-graveyard-grid::-webkit-scrollbar-thumb {
    background: rgba(148, 163, 184, 0.35);
    border-radius: 999px;
  }
  .board-zone-graveyard-grid .hand-card {
    width: 100%;
    max-width: none;
    margin-left: 0;
  }
  .board-zone-graveyard-grid .card-stack {
    width: 100%;
    max-width: none;
    min-height: 140px;
  }
  .board-zone-graveyard-grid .card-stack .hand-card {
    width: 100%;
    max-width: none;
  }
  .board-zone-permanents .board-zone-cards {
    justify-content: flex-end;
  }
  .board-zone-command .board-zone-cards {
    justify-content: center;
    flex-wrap: nowrap;
  }
  .board-zone-strip {
    flex-wrap: nowrap;
    overflow-x: auto;
    overflow-y: hidden;
    padding-bottom: 0.25rem;
    -webkit-overflow-scrolling: touch;
  }
  .board-zone-strip .hand-card {
    flex: 0 0 auto;
  }
  .board-zone-strip::-webkit-scrollbar {
    height: 6px;
  }
  .board-zone-strip::-webkit-scrollbar-thumb {
    background: rgba(148, 163, 184, 0.35);
    border-radius: 999px;
  }
  .board-zone-strip::-webkit-scrollbar-track {
    background: transparent;
  }
  .drop-target-active {
    outline: 2px dashed rgba(148, 180, 255, 0.65);
    outline-offset: 4px;
  }
  .board-zone-stack {
    position: relative;
    min-height: 200px;
    padding-bottom: 3rem;
  }
  .board-zone-stack .hand-card {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(
      calc(var(--stack-index, 0) * 20px),
      calc(var(--stack-index, 0) * 14px)
    );
    z-index: calc(100 + var(--stack-index, 0));
    max-width: 100px;
  }
  .board-zone-stack .hand-card:focus-visible {
    outline: 2px solid rgba(148, 180, 255, 0.75);
    outline-offset: 2px;
  }
  .card-stack {
    position: relative;
    min-height: 150px;
    width: min(160px, 100%);
    max-width: 180px;
  }
  .card-stack .stack-tap-btn {
    position: absolute;
    bottom: -0.4rem;
    left: 50%;
    transform: translateX(-50%);
    border: 1px solid rgba(148, 163, 184, 0.35);
    background: rgba(15, 23, 42, 0.8);
    color: #e2e8f0;
    border-radius: 999px;
    padding: 0.2rem 0.6rem;
    font-size: 0.65rem;
    line-height: 1;
    z-index: 40;
  }
  .card-stack .stack-tap-btn:hover,
  .card-stack .stack-tap-btn:focus-visible {
    background: rgba(15, 23, 42, 0.95);
  }
  .card-stack .hand-card {
    position: absolute;
    top: 0;
    left: 0;
    transform: translate(
      calc(var(--stack-index, 0) * 18px),
      calc(var(--stack-index, 0) * 12px)
    );
    transition: transform 0.18s ease, box-shadow 0.18s ease;
  }
  .card-stack .hand-card:hover {
    z-index: 25;
    transform: translate(
      calc(var(--stack-index, 0) * 18px),
      calc(var(--stack-index, 0) * 12px)
    ) scale(1.05);
    box-shadow: 0 0.5rem 1.25rem rgba(15, 23, 42, 0.35);
  }
  .board-zone-creatures { grid-area: creatures; }
  .board-zone-permanents { grid-area: permanents; }
  .board-zone-lands { grid-area: lands; }
  @media (max-width: 1199.98px) {
    .board-grid-layout {
      grid-template-areas:
        "commandColumn"
        "creatures"
        "permanents"
        "lands";
      grid-template-columns: 1fr;
    }
    .board-zone-stack {
      position: relative;
      min-height: auto;
      padding-bottom: 0;
    }
    .board-zone-stack .hand-card {
      position: static;
      transform: none;
      margin-bottom: 0.75rem;
    }
  }
  .board-actions {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
  }
  .board-actions .btn {
    min-width: 150px;
  }
  .board-note {
    color: var(--bs-secondary-color);
    font-size: 0.8rem;
  }
  .fetch-card-option.active {
    border-color: rgba(148, 180, 255, 0.5) !important;
    box-shadow: 0 0 0 2px rgba(148, 180, 255, 0.2);
  }
  .hand-status {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
    align-items: center;
    margin-bottom: 0.75rem;
  }
  .hand-status .badge {
    font-size: 0.72rem;
  }
  .opening-hand-actions {
    position: fixed;
    left: calc(var(--sidebar-w, 0px) + 2rem);
    right: 2rem;
    bottom: var(--hand-actions-safe);
    z-index: 1040;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: space-between;
    gap: 0.65rem;
    padding: 0.65rem 0.5rem;
    background: transparent;
    border: 0;
    box-shadow: none;
    backdrop-filter: none;
    overflow-x: auto;
    pointer-events: auto;
  }
  .opening-hand-actions .btn {
    min-width: 0;
    font-size: 0.85rem;
    padding: 0.45rem 0.9rem;
    border-radius: 999px;
    white-space: nowrap;
  }
  .opening-hand-actions .action-group {
    display: inline-flex;
    align-items: center;
    gap: 0.65rem;
    flex-wrap: wrap;
  }
  .opening-hand-actions .action-group-right {
    margin-left: auto;
  }
  @media (max-width: 992px) {
    .opening-hand-actions {
      left: 1rem;
      right: 1rem;
    }
  }
  @media (max-width: 576px) {
    .hand-card-grid {
      justify-content: flex-start;
      padding-left: 1rem;
      padding-right: 1rem;
    }
    .hand-card {
      scroll-snap-align: center;
    }
    .hand-card-grid .hand-card {
      width: clamp(110px, 44vw, 150px);
      margin-left: -16px;
    }
    .hand-card-grid .hand-card:first-child {
      margin-left: 0;
    }
  }
  .card-context-menu {
    position: fixed;
    min-width: 220px;
    max-width: 260px;
    padding: 0.4rem 0;
    background: rgba(15, 23, 42, 0.95);
    border: 1px solid rgba(148, 163, 184, 0.35);
    border-radius: 0.65rem;
    z-index: 5000;
    backdrop-filter: blur(8px);
  }
  .card-context-item {
    width: 100%;
    border: 0;
    background: transparent;
    color: var(--bs-body-color);
    text-align: left;
    font-size: 0.85rem;
    padding: 0.45rem 0.95rem;
    transition: background-color 0.15s ease, color 0.15s ease;
  }
  .card-context-item:hover,
  .card-context-item:focus {
    background: rgba(99, 102, 241, 0.25);
    color: #e0e7ff;
  }
  .card-context-item + .card-context-item {
    border-top: 1px solid rgba(148, 163, 184, 0.18);
  }
  #fetchCardModal .modal-dialog {
    max-width: 900px;
  }
  .fetch-card-option {
    background: linear-gradient(145deg, rgba(15, 23, 42, 0.8), rgba(30, 41, 59, 0.8));
    border: 1px solid rgba(148, 163, 184, 0.2);
    border-radius: 0.85rem;
    padding: 0.85rem;
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    transition: border-color 0.18s ease, box-shadow 0.18s ease, transform 0.18s ease;
  }
  .fetch-card-option:hover,
  .fetch-card-option:focus-visible {
    border-color: rgba(99, 102, 241, 0.5);
    box-shadow: 0 0.5rem 1.25rem rgba(15, 23, 42, 0.35);
    transform: translateY(-2px);
  }
  .fetch-option-title {
    font-size: 0.9rem;
    font-weight: 600;
    text-align: center;
    width: 100%;
    line-height: 1.2;
  }
  .fetch-option-subtitle {
    font-size: 0.75rem;
    text-align: center;
    width: 100%;
    color: var(--bs-secondary-color);
  }
  .fetch-card-thumb {
    width: 100%;
    max-width: 120px;
    aspect-ratio: 0.72;
    border-radius: 0.85rem;
    overflow: hidden;
    box-shadow: 0 0.65rem 1.4rem rgba(15, 23, 42, 0.35);
  }
  .fetch-card-thumb img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  .fetch-card-list {
    max-height: 60vh;
    overflow-y: auto;
    padding-right: 4px;
  }
  .scry-preview {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 0.85rem;
    max-height: 55vh;
    overflow-y: auto;
    padding-right: 4px;
  }
  .scry-card {
    background: rgba(15, 23, 42, 0.65);
    border: 1px solid rgba(148, 163, 184, 0.2);
    border-radius: 0.85rem;
    padding: 0.6rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  .scry-card img {
    width: 100%;
    aspect-ratio: 0.718;
    border-radius: 0.65rem;
    object-fit: cover;
  }
  .scry-card .scry-name {
    font-weight: 600;
    font-size: 0.85rem;
  }
  .scry-top-list {
    display: flex;
    flex-direction: column;
    gap: 0.45rem;
  }
  .scry-top-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
    padding: 0.35rem 0.6rem;
    border-radius: 0.6rem;
    background: rgba(15, 23, 42, 0.6);
    border: 1px solid rgba(148, 163, 184, 0.2);
    font-size: 0.85rem;
  }
</style>

{% set selection_active = selected_deck_id or selected_deck_list %}
<div class="opening-hand-stage{% if selection_active %} compact-mode{% endif %}">
<div class="opening-hand-header">
  <h1 class="mb-1">Opening Hand Simulator</h1>
  <div class="text-muted small">
    Shuffle your selected deck, then drag cards between zones to track your opening hand.
  </div>
</div>

<div class="card shadow-sm border-0 opening-hand-board">
  <div class="card-body">
    <div class="d-flex flex-wrap align-items-start justify-content-between gap-3 mb-3">
      <div>
        <h2 class="h6 text-uppercase text-muted mb-1">The Board</h2>
        <div class="board-note">
          Creatures rally on the left, artifacts and other permanents line the right column, lands hold the third row, and the command zone sits above a dedicated graveyard lane. Drag cards between zones, reorder them, right-click for more actions, or double-click a permanent to slip it back into your hand.
      </div>
    </div>
      <div class="board-actions">
        <button class="btn btn-outline-primary btn-sm" type="button" id="fetchCardBtn" data-bs-toggle="modal" data-bs-target="#fetchCardModal">
          <i class="bi bi-search"></i>
          Fetch Card
        </button>
        <button class="btn btn-outline-secondary btn-sm" type="button" id="tokenPickerBtn" data-bs-toggle="modal" data-bs-target="#tokenPickerModal">
          <i class="bi bi-stars"></i>
          Tokens
        </button>
      </div>
    </div>

    <div class="board-grid-layout" id="boardArea">
      <section class="board-zone board-zone-creatures" data-board-zone="creatures" hidden>
        <div class="board-zone-header">Creatures</div>
        <div id="boardCreatures" class="board-zone-cards board-zone-strip" data-empty-text="No creatures on the battlefield yet."></div>
      </section>
      <section class="board-zone board-zone-permanents" data-board-zone="permanents" hidden>
        <div class="board-zone-header">Artifacts / Enchantments / Planeswalkers / Battles</div>
        <div id="boardPermanents" class="board-zone-cards board-zone-strip" data-empty-text="No supporting permanents yet."></div>
      </section>
      <section class="board-zone board-zone-lands" data-board-zone="lands" hidden>
        <div class="board-zone-header">Lands</div>
        <div id="boardLands" class="board-zone-cards board-zone-strip" data-empty-text="No lands in play yet."></div>
      </section>
      <div class="board-column-command">
        <section class="board-zone board-zone-command" data-board-zone="command">
          <div class="board-zone-header">Command Zone</div>
          <div id="boardCommand" class="board-zone-cards board-zone-strip" data-empty-text="No commanders ready yet."></div>
        </section>
        <section class="board-zone board-zone-graveyard" data-board-zone="graveyard">
          <div class="board-zone-header">
            Graveyard
            <span class="badge rounded-pill text-bg-secondary" id="graveyardCount" hidden>0</span>
          </div>
          <div id="boardGraveyard" class="board-zone-cards board-zone-graveyard-grid" data-empty-text="No cards in the graveyard yet."></div>
        </section>
      </div>
    </div>
  </div>
</div>

<div class="opening-hand-layout{% if selection_active %} full-mode{% endif %}">
  <section class="card shadow-sm border-0{% if selection_active %} d-none{% endif %}" id="deckSourceCard">
    <div class="card-body">
      <h2 class="h6 text-uppercase text-muted mb-3">Deck Source</h2>

      <div class="d-flex flex-column gap-3 mb-3">
        <div>
          <label id="deckSelectLabel" class="form-label">Choose a deck</label>
          <div class="dropdown dv-select w-100" data-dv-select="deck">
            <input type="hidden" id="deckSelect" data-dv-select-input value="{{ selected_deck_id or '' }}">
            <button class="btn dv-select-toggle w-100 justify-content-between" type="button" id="deckSelectToggle" data-bs-toggle="dropdown" aria-expanded="false" aria-labelledby="deckSelectLabel deckSelectToggle">
              <span data-dv-select-label>{% if selected_deck_id %}{{ selected_deck_name }}{% else %}Select a deck{% endif %}</span>
              <i class="bi bi-chevron-down"></i>
            </button>
            <ul class="dropdown-menu dv-select-menu w-100" aria-labelledby="deckSelectToggle">
              <li>
                <button class="dropdown-item active" type="button" data-dv-select-option data-value="" data-label="Select a deck">Select a deck</button>
              </li>
              {% for deck in deck_options %}
                <li>
                  <button class="dropdown-item" type="button" data-dv-select-option data-value="{{ deck.id }}" data-label="{{ deck.name }}">{{ deck.name }}</button>
                </li>
              {% endfor %}
            </ul>
          </div>
          <div class="form-text">Choose one of your saved decks or proxy builds to use its draw pile. Commanders stored with the deck or build are automatically excluded.</div>
        </div>
        <div class="d-flex flex-wrap align-items-center gap-3">
          <button class="btn btn-outline-theme" type="button" data-bs-toggle="modal" data-bs-target="#deckPickerModal" id="deckListBtn">
            Paste Deck List
          </button>
          <span class="text-muted small" id="deckPickerSummary">No deck selected</span>
        </div>
      </div>

      <div class="alert alert-info small mt-3 d-none" role="status" id="handMessage"></div>
      <div class="alert alert-warning small mt-3 d-none" role="alert" id="handWarnings"></div>

      <input type="hidden" id="handState" value="">
    </div>
  </section>

  <section class="opening-hand-hand-wrapper">
    <div class="card shadow-sm border-0 opening-hand-hand">
      <div class="card-body">
        <div class="hand-status">
          <span class="badge text-bg-primary text-uppercase" id="handDeckName">{{ selected_deck_name or 'No deck selected' }}</span>
          <span class="badge text-bg-secondary" id="handRemaining" hidden></span>
        </div>
        <div class="hand-card-grid" id="handGrid">
          <div class="text-muted small">
            Shuffle a deck to see your opening seven.
          </div>
        </div>
      </div>
    </div>
    <div class="opening-hand-actions{% if not selection_active %} d-none{% endif %}" id="handActionBar">
      <div class="action-group action-group-left">
        <button class="btn btn-primary" type="button" id="shuffleBtn">
          Shuffle &amp; Deal
        </button>
        <button class="btn btn-outline-warning" type="button" id="newDeckBtn">
          Select New Deck
        </button>
        <button class="btn btn-outline-secondary" type="button" id="resetBtn">
          Reset
        </button>
      </div>
      <div class="action-group action-group-right">
        <button class="btn btn-outline-info" type="button" id="scryBtn" data-bs-toggle="modal" data-bs-target="#scryModal" disabled>
          Scry / Surveil
        </button>
        <button class="btn btn-outline-theme" type="button" id="drawBtn" disabled>
          Draw 1
        </button>
        <button class="btn btn-outline-success" type="button" id="untapAllBtn">
          Untap All
        </button>
      </div>
    </div>

  </section>
</div>
</div>


{% from "macros/modal_wrapper.html" import wrap_modal %}
{% call wrap_modal() %}
<div class="modal fade" id="deckPickerModal" tabindex="-1" aria-labelledby="deckPickerLabel" aria-hidden="true" role="dialog" aria-modal="true">
  <div class="modal-dialog modal-lg modal-dialog-centered">
    <div class="modal-content bg-dark text-light border border-secondary">
      <div class="modal-header border-secondary-subtle">
        <h5 class="modal-title" id="deckPickerLabel">Paste a Deck List</h5>
        {% if is_mobile %}{% include "components/modal_close_btn.html" %}{% endif %}
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="border rounded-3 p-3 bg-body-tertiary">
          <label for="deckListInput" class="form-label">Deck list</label>
          <textarea id="deckListInput" class="form-control" rows="6" placeholder="7 Island&#10;1 Sol Ring&#10;1 Rhystic Study">{{ (selected_deck_list or '') | e }}</textarea>
          <div class="form-text mt-2">Provide quantities like "2 Lightning Bolt" or "2x Lightning Bolt". The pasted list replaces any selected deck for this shuffle.</div>
        </div>
        <div class="border rounded-3 p-3 bg-body-tertiary mt-3">
          <label for="commanderInput" class="form-label">Commander name (optional)</label>
          <input type="text" id="commanderInput" class="form-control" placeholder="Commander name(s) to exclude" value="{{ (selected_commander_name or '') | e }}">
          <div class="form-text mt-2">If your list includes partners or special commanders, list them here (use "//" between names) so they stay out of the draw.</div>
        </div>
      </div>
      <div class="modal-footer border-secondary-subtle">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary" data-bs-dismiss="modal" id="deckPickerApply">Use deck list</button>
      </div>
    </div>
  </div>
</div>
{% endcall %}

<template id="handCardTemplate">
  <div class="hand-card">
    <div class="image-wrapper">
      <span class="card-art">
        <img loading="lazy" alt="">
      </span>
    </div>
    <div class="name"></div>
  </div>
</template>

{% call wrap_modal() %}
<div class="modal fade" id="fetchCardModal" tabindex="-1" aria-labelledby="fetchCardModalLabel" aria-hidden="true" role="dialog" aria-modal="true">
  <div class="modal-dialog modal-dialog-centered modal-lg">
    <div class="modal-content bg-dark text-light border border-secondary">
      <div class="modal-header border-secondary-subtle">
        <h5 class="modal-title" id="fetchCardModalLabel">Fetch a Card</h5>
        {% if is_mobile %}{% include "components/modal_close_btn.html" %}{% endif %}
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form id="fetchCardForm" class="modal-body">
        <div class="mb-3">
          <label for="fetchCardSearch" class="form-label">Find a card to fetch</label>
          <input
            type="search"
            class="form-control"
            id="fetchCardSearch"
            placeholder="Search name, type, or mana value">
          <input type="hidden" id="fetchCardName" name="name">
          <div class="form-text">
            Cards come from the selected deck. Type to filter, or type a custom name to add a card not in the list.
          </div>
        </div>
        <div id="fetchCardEmpty" class="text-muted small fst-italic d-none">No cards match that search.</div>
        <div class="row g-3 fetch-card-list" id="fetchCardList"></div>
        <div class="mb-3">
          <label for="fetchCardImage" class="form-label">Image URL (optional)</label>
          <input
            type="url"
            class="form-control"
            id="fetchCardImage"
            name="image"
            placeholder="https://...">
          <div class="form-text text-muted">
            Leave blank to use the generic placeholder art.
          </div>
        </div>
        <div class="mb-3">
          <label for="fetchCardZoneToggle" class="form-label">Destination</label>
          <div class="dropdown dv-select w-100" data-fetch-select="zone">
            <input
              type="hidden"
              id="fetchCardZone"
              name="zone"
              value="hand"
              data-dv-select-input>
            <button
              class="btn dv-select-toggle w-100 justify-content-between"
              type="button"
              id="fetchCardZoneToggle"
              data-bs-toggle="dropdown"
              aria-expanded="false">
              <span data-dv-select-label>Put into hand</span>
              <i class="bi bi-chevron-down"></i>
            </button>
            <ul class="dropdown-menu dv-select-menu w-100" aria-labelledby="fetchCardZoneToggle">
              <li>
                <button class="dropdown-item active" type="button" data-dv-select-option data-value="hand" data-label="Put into hand">
                  Put into hand
                </button>
              </li>
              <li>
                <button class="dropdown-item" type="button" data-dv-select-option data-value="board:creatures" data-label="Battlefield - Creatures">
                  Battlefield - Creatures
                </button>
              </li>
              <li>
                <button class="dropdown-item" type="button" data-dv-select-option data-value="board:permanents" data-label="Battlefield - Noncreature">
                  Battlefield - Noncreature
                </button>
              </li>
              <li>
                <button class="dropdown-item" type="button" data-dv-select-option data-value="board:lands" data-label="Battlefield - Lands">
                  Battlefield - Lands
                </button>
              </li>
              <li>
                <button class="dropdown-item" type="button" data-dv-select-option data-value="board:command" data-label="Command Zone">
                  Command Zone
                </button>
              </li>
              <li>
                <button class="dropdown-item" type="button" data-dv-select-option data-value="board:graveyard" data-label="Graveyard">
                  Graveyard
                </button>
              </li>
            </ul>
          </div>
        </div>
      <div class="modal-footer border-0">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="fetchCardSubmit">Add Card</button>
      </div>
    </form>
  </div>
</div>
{% endcall %}
</div>

{% call wrap_modal() %}
<div class="modal fade" id="tokenPickerModal" tabindex="-1" aria-labelledby="tokenPickerLabel" aria-hidden="true" role="dialog" aria-modal="true">
  <div class="modal-dialog modal-dialog-centered modal-lg">
    <div class="modal-content bg-dark text-light border border-secondary">
      <div class="modal-header border-secondary-subtle">
        <h5 class="modal-title" id="tokenPickerLabel">Add a Token</h5>
        {% if is_mobile %}{% include "components/modal_close_btn.html" %}{% endif %}
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="text-muted small mb-3">Tokens are pulled from the selected deck's printings. Pick one to place it on the battlefield.</div>
        <div class="mb-3">
          <label for="tokenPickerSearch" class="form-label">Find a token</label>
          <input
            type="search"
            class="form-control"
            id="tokenPickerSearch"
            placeholder="Search token name or type">
          <div class="form-text">Type to filter tokens or enter a name to add a custom token.</div>
        </div>
        <div id="tokenPickerCustom" class="d-none mb-3">
          <button type="button" class="btn btn-outline-primary w-100" id="tokenPickerCustomBtn">Add custom token</button>
        </div>
        <div id="tokenPickerList" class="row g-3"></div>
        <div id="tokenPickerEmpty" class="text-muted small text-center">Select a deck to view its tokens.</div>
        <div id="tokenPickerNoMatch" class="text-muted small text-center d-none">No tokens match that search.</div>
        <hr class="border-secondary-subtle my-4">
        <div class="text-muted small text-uppercase mb-2">Search all tokens</div>
        <div class="mb-3">
          <label for="tokenAllSearch" class="form-label">Token name or type</label>
          <input
            type="search"
            class="form-control"
            id="tokenAllSearch"
            placeholder="Search all tokens">
          <div class="form-text">Search across every token, not just this deck.</div>
        </div>
        <div id="tokenAllCustom" class="d-none mb-3">
          <button type="button" class="btn btn-outline-primary w-100" id="tokenAllCustomBtn">Add custom token</button>
        </div>
        <div id="tokenAllList" class="row g-3"></div>
        <div id="tokenAllEmpty" class="text-muted small text-center">Search for a token to add it.</div>
        <div id="tokenAllNoMatch" class="text-muted small text-center d-none">No tokens match that search.</div>
      </div>
      <div class="modal-footer border-secondary-subtle d-flex justify-content-between">
        <div class="text-muted small" id="tokenPickerStatus"></div>
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>
{% endcall %}

{% call wrap_modal() %}
<div class="modal fade" id="scryModal" tabindex="-1" aria-labelledby="scryModalLabel" aria-hidden="true" role="dialog" aria-modal="true">
  <div class="modal-dialog modal-xl modal-dialog-centered">
    <div class="modal-content bg-dark text-light border border-secondary">
      <div class="modal-header border-secondary-subtle">
        <h5 class="modal-title" id="scryModalLabel">Scry / Surveil</h5>
        {% if is_mobile %}{% include "components/modal_close_btn.html" %}{% endif %}
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="row g-3 align-items-end mb-3">
          <div class="col-12 col-lg-4">
            <label for="scryMode" class="form-label">Mode</label>
            <select id="scryMode" class="form-select form-select-sm">
              <option value="scry">Scry (put any on bottom)</option>
              <option value="surveil">Surveil (put any in graveyard)</option>
            </select>
          </div>
          <div class="col-12 col-lg-4">
            <label for="scryCount" class="form-label">Cards to look at</label>
            <input type="number" id="scryCount" class="form-control form-control-sm" min="1" max="10" value="1">
          </div>
          <div class="col-12 col-lg-4">
            <button type="button" class="btn btn-outline-primary w-100" id="scryPreviewBtn">Preview Top Cards</button>
          </div>
        </div>
        <div class="row g-3">
          <div class="col-12 col-lg-8">
            <div class="scry-preview" id="scryPreview"></div>
            <div class="text-muted small mt-2" id="scryPreviewHint"></div>
          </div>
          <div class="col-12 col-lg-4">
            <div class="text-uppercase text-muted small fw-semibold mb-2">Top Order</div>
            <div class="scry-top-list" id="scryTopList"></div>
            <div class="text-muted small mt-2" id="scryTopHint">Cards kept on top will be drawn in this order.</div>
          </div>
        </div>
      </div>
      <div class="modal-footer border-secondary-subtle">
        <div class="text-muted small me-auto" id="scryStatus"></div>
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" id="scryApplyBtn">Apply</button>
      </div>
    </div>
  </div>
</div>
{% endcall %}

<script nonce="{{ csp_nonce() }}">
(function () {
  const deckListInput = document.getElementById('deckListInput');
  const commanderInput = document.getElementById('commanderInput');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const resetBtn = document.getElementById('resetBtn');
  const drawBtn = document.getElementById('drawBtn');
  const stateInput = document.getElementById('handState');
  const handGrid = document.getElementById('handGrid');
  const handDeckName = document.getElementById('handDeckName');
  const handRemaining = document.getElementById('handRemaining');
  const handMessage = document.getElementById('handMessage');
  const handWarnings = document.getElementById('handWarnings');
  const fetchCardModalEl = document.getElementById('fetchCardModal');
  const fetchCardForm = document.getElementById('fetchCardForm');
  const fetchCardSubmit = document.getElementById('fetchCardSubmit');
  const handCardTemplate = document.getElementById('handCardTemplate');
  const deckSelectWrapper = document.querySelector('[data-dv-select="deck"]');
  const deckSelectInput = deckSelectWrapper ? deckSelectWrapper.querySelector('[data-dv-select-input]') : null;
  const deckSelectLabelEl = deckSelectWrapper ? deckSelectWrapper.querySelector('[data-dv-select-label]') : null;
  const deckOptionButtons = deckSelectWrapper ? Array.from(deckSelectWrapper.querySelectorAll('[data-dv-select-option]')) : [];
  const fetchNameSelect = null;
  const fetchZoneSelect = document.querySelector('[data-fetch-select="zone"]');
  const handActionBar = document.getElementById('handActionBar');
  const newDeckBtn = document.getElementById('newDeckBtn');
  const deckPickerModal = document.getElementById('deckPickerModal');
  const tokenPickerBtn = document.getElementById('tokenPickerBtn');
  const tokenPickerModal = document.getElementById('tokenPickerModal');
  const tokenPickerList = document.getElementById('tokenPickerList');
  const tokenPickerEmpty = document.getElementById('tokenPickerEmpty');
  const tokenPickerNoMatch = document.getElementById('tokenPickerNoMatch');
  const tokenPickerSearch = document.getElementById('tokenPickerSearch');
  const tokenPickerCustom = document.getElementById('tokenPickerCustom');
  const tokenPickerCustomBtn = document.getElementById('tokenPickerCustomBtn');
  const tokenAllSearch = document.getElementById('tokenAllSearch');
  const tokenAllList = document.getElementById('tokenAllList');
  const tokenAllEmpty = document.getElementById('tokenAllEmpty');
  const tokenAllNoMatch = document.getElementById('tokenAllNoMatch');
  const tokenAllCustom = document.getElementById('tokenAllCustom');
  const tokenAllCustomBtn = document.getElementById('tokenAllCustomBtn');
  const tokenPickerStatus = document.getElementById('tokenPickerStatus');
  const untapAllBtn = document.getElementById('untapAllBtn');
  const scryBtn = document.getElementById('scryBtn');
  const scryModal = document.getElementById('scryModal');
  const scryMode = document.getElementById('scryMode');
  const scryCount = document.getElementById('scryCount');
  const scryPreviewBtn = document.getElementById('scryPreviewBtn');
  const scryPreview = document.getElementById('scryPreview');
  const scryPreviewHint = document.getElementById('scryPreviewHint');
  const scryTopList = document.getElementById('scryTopList');
  const scryTopHint = document.getElementById('scryTopHint');
  const scryStatus = document.getElementById('scryStatus');
  const scryApplyBtn = document.getElementById('scryApplyBtn');
  const graveyardCount = document.getElementById('graveyardCount');
  const fetchCardName = document.getElementById('fetchCardName');
  const fetchCardList = document.getElementById('fetchCardList');
  const fetchCardSearch = document.getElementById('fetchCardSearch');
  const fetchCardEmpty = document.getElementById('fetchCardEmpty');
  const deckPickerSummary = document.getElementById('deckPickerSummary');
  const deckPickerApply = document.getElementById('deckPickerApply');
  const deckSourceCard = document.getElementById('deckSourceCard');
  const openingLayout = document.querySelector('.opening-hand-layout');
  const openingStage = document.querySelector('.opening-hand-stage');
  const sidebarCollapseBtn = document.getElementById('sidebarCollapseBtn');
  const placeholderImage = "{{ static_url('img/card-placeholder.svg') }}";
  const deckCardLookup = {{ deck_card_lookup_json | safe }} || {};
  const deckTokenLookup = {{ deck_token_lookup_json | safe }} || {};
  const customTokenEntries = {{ custom_token_entries_json | default('[]', true) | safe }} || [];
  const commanderSeedPayload = {{ selected_commander_cards_json | default('[]', true) | safe }} || [];
  const csrfToken = window.csrfToken || document.querySelector('meta[name="csrf-token"]')?.content || '';
  let sidebarRestoreState = null;
  let commanderSeed = Array.isArray(commanderSeedPayload) ? commanderSeedPayload.slice() : [];
  let tokenAllSearchTimer = null;
  let tokenAllLastQuery = '';
  let scryCards = [];
  let scryChoices = new Map();
  let scryTopOrder = [];

  const boardContainers = {
    creatures: document.getElementById('boardCreatures'),
    permanents: document.getElementById('boardPermanents'),
    lands: document.getElementById('boardLands'),
    command: document.getElementById('boardCommand'),
    graveyard: document.getElementById('boardGraveyard')
  };
  const boardZoneRoots = {
    creatures: document.querySelector('[data-board-zone="creatures"]'),
    permanents: document.querySelector('[data-board-zone="permanents"]'),
    lands: document.querySelector('[data-board-zone="lands"]'),
    command: document.querySelector('[data-board-zone="command"]'),
    graveyard: document.querySelector('[data-board-zone="graveyard"]')
  };

  const boardState = {
    creatures: [],
    permanents: [],
    lands: [],
    command: [],
    graveyard: []
  };
  const boardZones = Object.keys(boardState);
  Object.entries(boardContainers).forEach(function ([zoneKey, container]) {
    if (!container) {
      return;
    }
    container.addEventListener('dragover', function (event) {
      handleZoneDragOver(event, zoneKey);
    });
    container.addEventListener('drop', function (event) {
      handleZoneDrop(event, zoneKey);
    });
  });

  let handCards = [];
  let cardSerial = 0;
  let dragContext = null;
  let contextMenuRef = null;
  let contextCard = null;
  let activeDropTarget = null;
  let fetchNameSearchInput = null;
  let fetchCardOptions = {};
  let tokenModalInstance = null;
  let lastTokenDeckId = null;
  const BASIC_LAND_NAMES = new Set([
    'plains',
    'island',
    'swamp',
    'mountain',
    'forest',
    'wastes',
    'snow-covered plains',
    'snow-covered island',
    'snow-covered swamp',
    'snow-covered mountain',
    'snow-covered forest',
    'snow-covered wastes',
  ]);

  function setDeckSelection(value, label) {
    const normalizedValue = value || '';
    const normalizedLabel = label || 'Select a deck';
    if (deckOptionButtons.length) {
      deckOptionButtons.forEach((btn) => {
        btn.classList.toggle('active', btn.dataset.value === normalizedValue);
      });
    }
    if (deckSelectInput) {
      deckSelectInput.value = normalizedValue;
    }
    if (deckSelectLabelEl) {
      deckSelectLabelEl.textContent = normalizedLabel;
    }
    if (deckSelectWrapper) {
      deckSelectWrapper.dataset.dvSelectValue = normalizedValue;
    }
  }

  deckOptionButtons.forEach((btn) => {
    btn.addEventListener('click', (evt) => {
      evt.preventDefault();
      const val = btn.dataset.value || '';
      const lbl = btn.dataset.label || btn.textContent.trim();
      setDeckSelection(val, lbl);
    });
  });

  function updateDvSelect(wrapper, value, label, options) {
    if (!wrapper) {
      return;
    }
    const opts = options || {};
    const normalizedValue = value ?? '';
    const placeholder = wrapper.dataset.placeholder || wrapper.getAttribute('data-placeholder') || 'Select an option';
    const normalizedLabel = label || placeholder;
    const hiddenInput = wrapper.querySelector('[data-dv-select-input]');
    const labelEl = wrapper.querySelector('[data-dv-select-label]');
    const toggleBtn = wrapper.querySelector('.dv-select-toggle');
    const optionButtons = Array.from(wrapper.querySelectorAll('[data-dv-select-option]'));

    optionButtons.forEach((btn) => {
      btn.classList.toggle('active', (btn.dataset.value ?? '') === normalizedValue);
    });

    if (hiddenInput && hiddenInput.value !== normalizedValue) {
      hiddenInput.value = normalizedValue;
      hiddenInput.dispatchEvent(new Event('input', { bubbles: true }));
      hiddenInput.dispatchEvent(new Event('change', { bubbles: true }));
    }

    if (labelEl) {
      labelEl.textContent = normalizedLabel;
    }

    wrapper.dataset.dvSelectValue = normalizedValue;

    if (opts.hide === true && toggleBtn && typeof bootstrap !== 'undefined' && bootstrap.Dropdown) {
      try {
        bootstrap.Dropdown.getOrCreateInstance(toggleBtn).hide();
      } catch (_) {
        /* noop */
      }
    }

    if (opts.trigger === true) {
      wrapper.dispatchEvent(
        new CustomEvent('dv-select:change', {
          detail: { value: normalizedValue, label: normalizedLabel },
        }),
      );
    }
  }

  function refreshDvSelect(wrapper) {
    if (!wrapper) {
      return;
    }
    const placeholder = wrapper.dataset.placeholder || wrapper.getAttribute('data-placeholder') || 'Select an option';
    wrapper.dataset.placeholder = placeholder;
    const optionButtons = Array.from(wrapper.querySelectorAll('[data-dv-select-option]'));
    const hiddenInput = wrapper.querySelector('[data-dv-select-input]');
    const manualButton = wrapper.querySelector('button[data-custom="manual"]');

    optionButtons.forEach((btn) => {
      btn.addEventListener('click', (event) => {
        event.preventDefault();
        const value = btn.dataset.value ?? '';
        const label = btn.dataset.label ?? btn.textContent.trim();
        updateDvSelect(wrapper, value, label, { trigger: true, hide: true });
      });
    });

    if (manualButton) {
      manualButton.addEventListener('click', (event) => {
        event.preventDefault();
        const manualName = window.prompt('Enter a card name');
        if (!manualName) {
          updateDvSelect(wrapper, '', placeholder, { trigger: false, hide: true });
          return;
        }
        const trimmed = manualName.trim();
        if (!trimmed) {
          updateDvSelect(wrapper, '', placeholder, { trigger: false, hide: true });
          return;
        }
        if (wrapper === fetchNameSelect) {
          fetchCardOptions[trimmed] = {
            name: trimmed,
            image: null,
            hover: null,
            type_line: '',
            is_creature: false,
            is_land: false,
            is_instant: false,
            is_sorcery: false,
            is_permanent: true,
            zone_hint: 'permanents',
          };
        }
        updateDvSelect(wrapper, trimmed, trimmed, { trigger: true, hide: true });
      });
    }

    if (!optionButtons.length) {
      updateDvSelect(wrapper, '', placeholder, { trigger: false, hide: false });
      if (hiddenInput) {
        hiddenInput.value = '';
      }
      return;
    }

    const currentValue = hiddenInput?.value || wrapper.dataset.dvSelectValue || '';
    let activeItem = null;
    if (currentValue) {
      activeItem = optionButtons.find((btn) => (btn.dataset.value ?? '') === currentValue);
    }
    if (!activeItem) {
      activeItem = optionButtons.find((btn) => btn.classList.contains('active')) || null;
    }

    if (activeItem) {
      const value = activeItem.dataset.value ?? '';
      const label = activeItem.dataset.label ?? activeItem.textContent.trim();
      updateDvSelect(wrapper, value, label, { trigger: false, hide: false });
    } else {
      updateDvSelect(wrapper, '', placeholder, { trigger: false, hide: false });
    }
  }

  function normalizeCardName(value) {
    return String(value || '').toLowerCase().replace(/\s+/g, ' ').trim();
  }

  function isBasicLandName(value) {
    return BASIC_LAND_NAMES.has(normalizeCardName(value));
  }

  function parseDeckListNames(raw) {
    const names = new Set();
    if (!raw) {
      return names;
    }
    raw.split(/\r?\n/).forEach((line) => {
      const text = (line || '').trim();
      if (!text || text.startsWith('#')) {
        return;
      }
      let name = text;
      let match = text.match(/^\s*(\d+)\s*[xX]?\s+(.+)$/);
      if (match) {
        name = match[2];
      } else {
        match = text.match(/^\s*(.+?)\s*[xX]\s*(\d+)\s*$/);
        if (match) {
          name = match[1];
        }
      }
      const normalized = normalizeCardName(name);
      if (normalized) {
        names.add(normalized);
      }
    });
    return names;
  }

  function deckNameSetForSelection(deckId) {
    const names = new Set();
    if (deckId && Array.isArray(deckCardLookup[deckId])) {
      deckCardLookup[deckId].forEach((entry) => {
        const normalized = normalizeCardName(entry.name || entry.value || '');
        if (normalized) {
          names.add(normalized);
        }
      });
      return names;
    }
    const deckList = (deckListInput ? deckListInput.value : '').trim();
    if (deckList) {
      return parseDeckListNames(deckList);
    }
    return names;
  }

  function populateFetchList(deckId) {
    if (!fetchCardList || !fetchCardName || !fetchCardSearch || !fetchCardEmpty) {
      return;
    }
    const entries = (deckCardLookup[deckId] || []).filter(function (entry) {
      const name = (entry.name || entry.value || '').toLowerCase();
      const typeLine = (entry.type_line || '').toLowerCase();
      const isBasicLand = typeLine.includes('basic land');
      if (!name) return false;
      if (!isBasicLand) {
        const inHand = handCards.some(function (c) { return (c.name || '').toLowerCase() === name; });
        const onBoard = boardZones.some(function (zone) {
          return (boardState[zone] || []).some(function (c) { return (c.name || '').toLowerCase() === name; });
        });
        if (inHand || onBoard) {
          return false;
        }
      }
      return true;
    });
    fetchCardOptions = {};
    fetchCardList.innerHTML = '';

    entries.forEach(function (entry) {
      const value = entry.value || entry.name;
      const displayName = entry.name || value;
      const typeLine = entry.type_line || '';
      const manaValueRaw = entry.mana_value;
      const manaValue = manaValueRaw === null || manaValueRaw === undefined ? '' : String(manaValueRaw);
      const lowerName = displayName.toLowerCase();
      const lowerType = typeLine.toLowerCase();
      fetchCardOptions[value] = {
        name: displayName,
        image: entry.image || entry.hover || null,
        hover: entry.hover || entry.image || null,
        back_image: entry.back_image || null,
        back_hover: entry.back_hover || entry.back_image || null,
        type_line: typeLine,
        mana_value: manaValueRaw,
        is_creature: Boolean(entry.is_creature),
        is_land: Boolean(entry.is_land),
        is_instant: Boolean(entry.is_instant),
        is_sorcery: Boolean(entry.is_sorcery),
        is_permanent: Boolean(entry.is_permanent),
        zone_hint: entry.zone_hint || '',
        filter: `${lowerName} ${lowerType} ${manaValue}`.trim(),
      };

      const col = document.createElement('div');
      col.className = 'col-6 col-md-4 col-xl-3';
      col.dataset.fetchOption = '1';
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'btn fetch-card-option w-100 shadow-sm';
      btn.dataset.value = value;
      btn.dataset.filter = fetchCardOptions[value].filter;

      const thumb = document.createElement('div');
      thumb.className = 'fetch-card-thumb';
      const img = document.createElement('img');
      img.src = entry.image || placeholderImage;
      img.alt = displayName;
      thumb.appendChild(img);

      const title = document.createElement('div');
      title.className = 'fetch-option-title';
      title.textContent = displayName;
      const subtitle = document.createElement('div');
      subtitle.className = 'fetch-option-subtitle';
      subtitle.textContent = typeLine || '';

      btn.appendChild(thumb);
      btn.appendChild(title);
      if (subtitle.textContent) {
        btn.appendChild(subtitle);
      }
      btn.addEventListener('click', function () {
        setFetchSelection(value);
      });

      col.appendChild(btn);
      fetchCardList.appendChild(col);
    });

    fetchCardEmpty.classList.toggle('d-none', entries.length > 0);
    setFetchSelection('');
    applyFetchFilter(fetchCardSearch ? fetchCardSearch.value : '');
  }
  function currentDeckId() {
    if (!deckSelectWrapper) {
      return '';
    }
    return deckSelectInput ? (deckSelectInput.value || '') : '';
  }

  function hasDeckSelection() {
    const deckId = currentDeckId();
    const deckList = (deckListInput ? deckListInput.value : '').trim();
    return !!(deckId || deckList);
  }

  function updateActionVisibility() {
    const active = hasDeckSelection();
    const deckId = currentDeckId();
    const deckListText = (deckListInput ? deckListInput.value : '').trim();
    if (deckSourceCard) {
      deckSourceCard.classList.toggle('d-none', active);
    }
    if (openingLayout) {
      openingLayout.classList.toggle('full-mode', active);
    }
    if (openingStage) {
      openingStage.classList.toggle('compact-mode', active);
    }
    if (handDeckName) {
      if (deckId) {
        const labelEl = deckSelectWrapper ? deckSelectWrapper.querySelector('[data-dv-select-label]') : null;
        handDeckName.textContent = (labelEl && labelEl.textContent.trim()) || 'Selected deck';
      } else if (deckListText) {
        handDeckName.textContent = 'Custom list';
      } else {
        handDeckName.textContent = 'No deck selected';
      }
    }
    if (handActionBar) {
      handActionBar.classList.toggle('d-none', !active);
    }
    syncActionBarSpacing();
    syncSidebarCollapse(active);
    if (!active) {
      showMessage('Select a deck or paste a deck list to begin.', 'info');
    } else if (handMessage && handMessage.classList.contains('alert-info')) {
      showMessage('');
    }
    if (deckPickerSummary) {
      if (deckId) {
        const labelEl = deckSelectWrapper ? deckSelectWrapper.querySelector('[data-dv-select-label]') : null;
        deckPickerSummary.textContent = (labelEl && labelEl.textContent.trim()) || 'Deck selected';
      } else if (deckListText) {
        deckPickerSummary.textContent = 'Using pasted list';
      } else {
        deckPickerSummary.textContent = 'No deck selected';
      }
    }
    updateScryAvailability();
  }

  function syncSidebarCollapse(active) {
    const body = document.body;
    if (!body) {
      return;
    }
    if (active) {
      if (sidebarRestoreState === null) {
        sidebarRestoreState = body.classList.contains('sidebar-collapsed');
      }
      body.classList.add('sidebar-collapsed');
      if (sidebarCollapseBtn) {
        sidebarCollapseBtn.classList.add('collapsed');
        sidebarCollapseBtn.setAttribute('aria-pressed', 'true');
        sidebarCollapseBtn.setAttribute('aria-label', 'Expand sidebar');
        sidebarCollapseBtn.setAttribute('title', 'Expand sidebar');
      }
      return;
    }
    if (sidebarRestoreState !== null) {
      body.classList.toggle('sidebar-collapsed', sidebarRestoreState);
      if (sidebarCollapseBtn) {
        const collapsed = sidebarRestoreState;
        sidebarCollapseBtn.classList.toggle('collapsed', collapsed);
        sidebarCollapseBtn.setAttribute('aria-pressed', collapsed ? 'true' : 'false');
        sidebarCollapseBtn.setAttribute('aria-label', collapsed ? 'Expand sidebar' : 'Collapse sidebar');
        sidebarCollapseBtn.setAttribute('title', collapsed ? 'Expand sidebar' : 'Collapse sidebar');
      }
      sidebarRestoreState = null;
    }
  }

  function syncActionBarSpacing() {
    if (!openingStage || !handActionBar) {
      return;
    }
    if (handActionBar.classList.contains('d-none')) {
      openingStage.style.setProperty('--hand-actions-space', '0px');
      return;
    }
    const height = handActionBar.getBoundingClientRect().height || 0;
    const space = Math.ceil(height + 12);
    openingStage.style.setProperty('--hand-actions-space', `${space}px`);
  }

  if (fetchCardSearch) {
    fetchCardSearch.addEventListener('input', function (event) {
      applyFetchFilter(event.target.value || '');
    });
  }

  function tokensForDeck(deckId) {
    if (!deckId) {
      const deckList = (deckListInput ? deckListInput.value : '').trim();
      return deckList ? customTokenEntries : [];
    }
    return deckTokenLookup[deckId] || [];
  }

  function setTokenStatus(text, level) {
    if (!tokenPickerStatus) return;
    tokenPickerStatus.textContent = text || '';
    tokenPickerStatus.className = 'text-muted small';
    if (level === 'error') tokenPickerStatus.classList.add('text-danger');
    if (level === 'success') tokenPickerStatus.classList.add('text-success');
  }

  function applyTokenFilter(query) {
    if (!tokenPickerList) return;
    const needle = (query || '').toLowerCase().trim();
    const buttons = Array.from(tokenPickerList.querySelectorAll('[data-token-item="1"]'));
    let anyVisible = false;
    buttons.forEach(function (btn) {
      const filterText = btn.dataset.filter || '';
      const match = !needle || filterText.includes(needle);
      const wrapper = btn.closest('[data-token-entry]');
      if (wrapper) {
        wrapper.classList.toggle('d-none', !match);
      }
      if (match) {
        anyVisible = true;
      }
    });
    if (tokenPickerNoMatch) {
      tokenPickerNoMatch.classList.toggle('d-none', anyVisible || !needle);
    }
    if (tokenPickerCustom) {
      const showCustom = Boolean(needle) && !anyVisible;
      tokenPickerCustom.classList.toggle('d-none', !showCustom);
      if (tokenPickerCustomBtn) {
        tokenPickerCustomBtn.textContent = showCustom
          ? `Add "${query.trim()}" token`
          : 'Add custom token';
      }
    }
  }

  function clearTokenAllResults() {
    if (tokenAllList) {
      tokenAllList.innerHTML = '';
    }
    tokenAllLastQuery = '';
    if (tokenAllEmpty) {
      tokenAllEmpty.classList.remove('d-none');
    }
    if (tokenAllNoMatch) {
      tokenAllNoMatch.classList.add('d-none');
    }
    if (tokenAllCustom) {
      tokenAllCustom.classList.add('d-none');
    }
  }

  function renderTokenAllResults(tokens, query) {
    if (!tokenAllList) {
      return;
    }
    tokenAllList.innerHTML = '';
    const hasTokens = Array.isArray(tokens) && tokens.length > 0;
    if (tokenAllEmpty) {
      tokenAllEmpty.classList.toggle('d-none', Boolean(query));
    }
    if (tokenAllNoMatch) {
      tokenAllNoMatch.classList.toggle('d-none', !query || hasTokens);
    }
    if (tokenAllCustom) {
      const showCustom = Boolean(query) && !hasTokens;
      tokenAllCustom.classList.toggle('d-none', !showCustom);
      if (tokenAllCustomBtn) {
        tokenAllCustomBtn.textContent = showCustom ? `Add "${query}" token` : 'Add custom token';
      }
    }
    if (!hasTokens) {
      return;
    }
    tokens.forEach(function (token) {
      const col = document.createElement('div');
      col.className = 'col-12 col-sm-6 col-md-4';
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'btn w-100 text-start bg-dark text-light border border-secondary d-flex align-items-center gap-3';
      const thumb = document.createElement('div');
      thumb.className = 'flex-shrink-0 overflow-hidden rounded';
      thumb.style.width = '88px';
      thumb.style.aspectRatio = '0.72';
      const img = document.createElement('img');
      img.src = token.image || placeholderImage;
      img.alt = token.name || 'Token';
      img.className = 'w-100 h-100 object-fit-cover';
      thumb.appendChild(img);
      const body = document.createElement('div');
      body.className = 'flex-grow-1';
      const title = document.createElement('div');
      title.className = 'fw-semibold';
      title.textContent = token.name || 'Token';
      const subtitle = document.createElement('div');
      subtitle.className = 'text-muted small';
      subtitle.textContent = token.type_line || 'Token';
      body.appendChild(title);
      body.appendChild(subtitle);
      btn.appendChild(thumb);
      btn.appendChild(body);
      btn.addEventListener('click', function () {
        addTokenToBoard(token);
      });
      col.appendChild(btn);
      tokenAllList.appendChild(col);
    });
  }

  async function fetchTokenAllResults(query) {
    const trimmed = (query || '').trim();
    if (!trimmed || trimmed.length < 2) {
      clearTokenAllResults();
      return;
    }
    const requestQuery = trimmed;
    tokenAllLastQuery = requestQuery;
    try {
      const response = await fetch(`{{ url_for("views.opening_hand_token_search") }}?q=${encodeURIComponent(requestQuery)}`, {
        credentials: 'same-origin',
      });
      const data = await response.json();
      if (tokenAllLastQuery !== requestQuery) {
        return;
      }
      if (!response.ok || !data.ok) {
        renderTokenAllResults([], requestQuery);
        return;
      }
      renderTokenAllResults(data.tokens || [], requestQuery);
    } catch (err) {
      renderTokenAllResults([], trimmed);
    }
  }

  function applyFetchFilter(query) {
    if (!fetchCardList) return;
    const needle = (query || '').toLowerCase().trim();
    const buttons = Array.from(fetchCardList.querySelectorAll('.fetch-card-option'));
    let anyVisible = false;
    buttons.forEach(function (btn) {
      const filterText = btn.dataset.filter || '';
      const match = !needle || filterText.includes(needle);
      const wrapper = btn.closest('[data-fetch-option]');
      if (wrapper) {
        wrapper.classList.toggle('d-none', !match);
      }
      if (match) anyVisible = true;
    });
    fetchCardEmpty.classList.toggle('d-none', anyVisible);
  }

  function setFetchSelection(value) {
    const targetValue = value || '';
    const buttons = Array.from(fetchCardList ? fetchCardList.querySelectorAll('.fetch-card-option') : []);
    buttons.forEach(function (btn) {
      btn.classList.toggle('active', btn.dataset.value === targetValue);
    });
    if (fetchCardName) {
      fetchCardName.value = targetValue;
    }
    if (fetchCardSearch && targetValue) {
      const option = fetchCardOptions[targetValue];
      if (option) {
        fetchCardSearch.value = option.name;
      }
    }
  }

  function renderTokenList(deckId) {
    if (!tokenPickerList || !tokenPickerEmpty) return;
    tokenPickerList.innerHTML = '';
    const tokens = tokensForDeck(deckId);
    const deckListActive = !deckId && (deckListInput ? deckListInput.value.trim() : '');
    const hasTokens = Array.isArray(tokens) && tokens.length > 0;
    tokenPickerEmpty.classList.toggle('d-none', hasTokens);
    tokenPickerEmpty.textContent = deckId
      ? 'No tokens detected for this deck yet.'
      : deckListActive
        ? 'No tokens detected for this list yet.'
      : 'Select a deck to view its tokens.';
    if (!hasTokens) {
      if (deckId || deckListActive) {
        const col = document.createElement('div');
        col.className = 'col-12';
        col.dataset.tokenEntry = '1';
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'btn btn-outline-secondary w-100';
        btn.dataset.tokenItem = '1';
        btn.dataset.filter = 'token';
        btn.textContent = 'Add a generic token to the battlefield';
        btn.addEventListener('click', function () {
          addTokenToBoard({
            name: 'Token',
            image: null,
            hover: null,
            type_line: 'Token',
            is_creature: false,
            is_land: false,
            is_instant: false,
            is_sorcery: false,
            is_permanent: true,
            zone_hint: 'permanents',
          });
        });
        col.appendChild(btn);
        tokenPickerList.appendChild(col);
        tokenPickerEmpty.classList.add('d-none');
      }
      applyTokenFilter(tokenPickerSearch ? tokenPickerSearch.value : '');
      return;
    }

    tokens.forEach(function(token) {
      const col = document.createElement('div');
      col.className = 'col-12 col-sm-6 col-md-4';
      col.dataset.tokenEntry = '1';
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'btn w-100 text-start bg-dark text-light border border-secondary d-flex align-items-center gap-3';
      btn.dataset.tokenItem = '1';
      btn.dataset.filter = `${(token.name || '').toLowerCase()} ${(token.type_line || '').toLowerCase()}`.trim();
      const thumb = document.createElement('div');
      thumb.className = 'flex-shrink-0 overflow-hidden rounded';
      thumb.style.width = '88px';
      thumb.style.aspectRatio = '0.72';
      const img = document.createElement('img');
      img.src = token.image || placeholderImage;
      img.alt = token.name || 'Token';
      img.className = 'w-100 h-100 object-fit-cover';
      thumb.appendChild(img);
      const body = document.createElement('div');
      body.className = 'flex-grow-1';
      const title = document.createElement('div');
      title.className = 'fw-semibold';
      title.textContent = token.name || 'Token';
      const subtitle = document.createElement('div');
      subtitle.className = 'text-muted small';
      subtitle.textContent = token.type_line || 'Token';
      body.appendChild(title);
      body.appendChild(subtitle);
      btn.appendChild(thumb);
      btn.appendChild(body);
      btn.addEventListener('click', function() {
        addTokenToBoard(token);
      });
      col.appendChild(btn);
      tokenPickerList.appendChild(col);
    });
    applyTokenFilter(tokenPickerSearch ? tokenPickerSearch.value : '');
  }

  function addTokenToBoard(token) {
    const payload = normalizeCard({
      name: token && token.name ? token.name : 'Token',
      image: token && token.image ? token.image : placeholderImage,
      hover: token && (token.hover || token.image) ? (token.hover || token.image) : placeholderImage,
      type_line: token && token.type_line ? token.type_line : 'Token',
      is_creature: Boolean(token && token.is_creature),
      is_land: Boolean(token && token.is_land),
      is_instant: Boolean(token && token.is_instant),
      is_sorcery: Boolean(token && token.is_sorcery),
      is_permanent: Boolean(token && token.is_permanent),
      zone_hint: token && token.zone_hint ? token.zone_hint : 'permanents',
    });
    if (!payload) return;
    moveCardToBoard(payload, 'permanents');
    if (tokenModalInstance) {
      tokenModalInstance.hide();
    }
    setTokenStatus('Token added to battlefield.', 'success');
  }

  function applyCardFace(card) {
    if (!card) {
      return;
    }
    const frontImage = card.front_image || card.image || placeholderImage;
    const frontHover = card.front_hover || card.hover || frontImage;
    const backImage = card.back_image || null;
    const backHover = card.back_hover || backImage || frontHover;
    if (card.flipped && backImage) {
      card.image = backImage;
      card.hover = backHover;
    } else {
      card.image = frontImage;
      card.hover = frontHover;
    }
  }

  function toggleCardFace(card, source, zone) {
    if (!card || !card.back_image) {
      return;
    }
    card.flipped = !card.flipped;
    applyCardFace(card);
    if (source === 'board') {
      renderBoard();
    } else if (source === 'hand') {
      renderHand();
    } else if (zone) {
      renderBoard();
    } else {
      renderHand();
      renderBoard();
    }
  }

  function updateTokenPicker(deckId) {
    const tokens = tokensForDeck(deckId);
    const hasTokens = Array.isArray(tokens) && tokens.length > 0;
    if (tokenPickerBtn) {
      tokenPickerBtn.disabled = false;
      tokenPickerBtn.title = hasTokens ? '' : 'No tokens detected for this deck yet.';
    }
    if (!hasTokens && tokenPickerList) {
      tokenPickerList.innerHTML = '';
    }
    if (!hasTokens && tokenPickerStatus) {
      tokenPickerStatus.textContent = '';
    }
  }

  if (untapAllBtn) {
    untapAllBtn.addEventListener('click', function () {
      const changed = untapAllBoardCards();
      if (changed) {
        showMessage('All permanents untapped.', 'info');
      } else {
        showMessage('No tapped permanents on the battlefield.', 'info');
      }
    });
  }

  function normalizeCard(card) {
    if (!card) {
      return null;
    }
    const copy = Object.assign({}, card);
    copy.__uid = copy.__uid || 'card-' + Date.now() + '-' + (cardSerial++);
    copy.name = copy.name || card.name || 'Card';

    const fallbackImage = copy.image || card.image || card.normal || card.small || card.large || placeholderImage;
    copy.front_image = copy.front_image || card.front_image || card.frontImage || fallbackImage;
    copy.front_hover = copy.front_hover || card.front_hover || card.frontHover || copy.hover || card.hover || card.hover_image || card.hoverImage || copy.front_image;
    copy.back_image = copy.back_image || card.back_image || card.backImage || null;
    copy.back_hover = copy.back_hover || card.back_hover || card.backHover || copy.back_image || null;
    copy.flipped = Boolean(copy.flipped);
    applyCardFace(copy);
    copy.type_line = copy.type_line || card.type_line || card.typeLine || '';
    copy.tapped = Boolean(card.tapped);
    copy.is_creature = Boolean(copy.is_creature ?? card.is_creature ?? card.isCreature);
    copy.is_land = Boolean(copy.is_land ?? card.is_land ?? card.isLand);
    copy.is_instant = Boolean(copy.is_instant ?? card.is_instant ?? card.isInstant);
    copy.is_sorcery = Boolean(copy.is_sorcery ?? card.is_sorcery ?? card.isSorcery);
    copy.is_permanent = Boolean(copy.is_permanent ?? card.is_permanent ?? card.isPermanent);
    copy.zone_hint = copy.zone_hint || card.zone_hint || card.zoneHint || 'permanents';

    return copy;
  }

  function setCommanderSeed(cards) {
    commanderSeed = Array.isArray(cards) ? cards.slice() : [];
  }

  function seedCommandZone() {
    boardState.command = [];
    if (!commanderSeed.length) {
      return;
    }
    commanderSeed.forEach(function (entry) {
      const card = normalizeCard(entry);
      if (!card) {
        return;
      }
      card.boardZone = 'command';
      card.lastBoardZone = 'command';
      card.tapped = false;
      boardState.command.push(card);
    });
  }

  function showMessage(text, kind) {
    if (!handMessage) {
      return;
    }
    const tone = kind || 'info';
    if (!text) {
      handMessage.classList.add('d-none');
      handMessage.textContent = '';
      return;
    }
    handMessage.textContent = text;
    handMessage.className = 'alert alert-' + tone + ' small mt-3';
  }

  function showWarnings(warnings) {
    if (!handWarnings) {
      return;
    }
    if (!warnings || !warnings.length) {
      handWarnings.classList.add('d-none');
      handWarnings.textContent = '';
      return;
    }
    handWarnings.textContent = warnings.join(' ');
    handWarnings.className = 'alert alert-warning small mt-3';
  }

  function updateScryAvailability() {
    if (!scryBtn) {
      return;
    }
    const hasState = Boolean(stateInput && stateInput.value);
    scryBtn.disabled = !hasState;
  }

  function setScryStatus(message, tone) {
    if (!scryStatus) {
      return;
    }
    scryStatus.textContent = message || '';
    scryStatus.className = 'text-muted small';
    if (tone === 'warning') {
      scryStatus.className = 'text-warning small';
    } else if (tone === 'danger') {
      scryStatus.className = 'text-danger small';
    } else if (tone === 'success') {
      scryStatus.className = 'text-success small';
    }
  }

  function resetScryState() {
    scryCards = [];
    scryChoices = new Map();
    scryTopOrder = [];
    if (scryPreview) {
      scryPreview.innerHTML = '';
    }
    if (scryTopList) {
      scryTopList.innerHTML = '';
    }
    if (scryPreviewHint) {
      scryPreviewHint.textContent = '';
    }
    setScryStatus('');
  }

  function renderScryTopList() {
    if (!scryTopList) {
      return;
    }
    scryTopList.innerHTML = '';
    if (!scryTopOrder.length) {
      const empty = document.createElement('div');
      empty.className = 'text-muted small';
      empty.textContent = 'No cards kept on top.';
      scryTopList.appendChild(empty);
      return;
    }
    scryTopOrder.forEach(function (idx, position) {
      const card = scryCards[idx];
      if (!card) {
        return;
      }
      const row = document.createElement('div');
      row.className = 'scry-top-item';
      const label = document.createElement('div');
      label.textContent = `${position + 1}. ${card.name || 'Card'}`;
      const controls = document.createElement('div');
      const upBtn = document.createElement('button');
      upBtn.type = 'button';
      upBtn.className = 'btn btn-outline-light btn-sm';
      upBtn.textContent = 'Up';
      upBtn.disabled = position === 0;
      upBtn.addEventListener('click', function () {
        if (position <= 0) return;
        const copy = scryTopOrder.slice();
        const temp = copy[position - 1];
        copy[position - 1] = copy[position];
        copy[position] = temp;
        scryTopOrder = copy;
        renderScryTopList();
      });
      const downBtn = document.createElement('button');
      downBtn.type = 'button';
      downBtn.className = 'btn btn-outline-light btn-sm';
      downBtn.textContent = 'Down';
      downBtn.disabled = position === scryTopOrder.length - 1;
      downBtn.addEventListener('click', function () {
        if (position >= scryTopOrder.length - 1) return;
        const copy = scryTopOrder.slice();
        const temp = copy[position + 1];
        copy[position + 1] = copy[position];
        copy[position] = temp;
        scryTopOrder = copy;
        renderScryTopList();
      });
      controls.appendChild(upBtn);
      controls.appendChild(downBtn);
      row.appendChild(label);
      row.appendChild(controls);
      scryTopList.appendChild(row);
    });
  }

  function renderScryPreview() {
    if (!scryPreview) {
      return;
    }
    scryPreview.innerHTML = '';
    if (!scryCards.length) {
      const empty = document.createElement('div');
      empty.className = 'text-muted small';
      empty.textContent = 'No cards to preview yet.';
      scryPreview.appendChild(empty);
      renderScryTopList();
      return;
    }
    const mode = scryMode ? (scryMode.value || 'scry') : 'scry';
    const offLabel = mode === 'surveil' ? 'Graveyard' : 'Bottom';
    scryCards.forEach(function (card, idx) {
      const cardWrap = document.createElement('div');
      cardWrap.className = 'scry-card';
      const img = document.createElement('img');
      img.src = card.image || placeholderImage;
      img.alt = card.name || '';
      const title = document.createElement('div');
      title.className = 'scry-name';
      title.textContent = card.name || 'Card';
      const select = document.createElement('select');
      select.className = 'form-select form-select-sm';
      const keepOpt = document.createElement('option');
      keepOpt.value = 'top';
      keepOpt.textContent = 'Keep on top';
      const offOpt = document.createElement('option');
      offOpt.value = mode === 'surveil' ? 'graveyard' : 'bottom';
      offOpt.textContent = `Put in ${offLabel}`;
      select.appendChild(keepOpt);
      select.appendChild(offOpt);
      let choice = scryChoices.get(idx) || 'top';
      if (mode === 'surveil' && choice === 'bottom') {
        choice = 'graveyard';
        scryChoices.set(idx, choice);
      }
      if (mode === 'scry' && choice === 'graveyard') {
        choice = 'bottom';
        scryChoices.set(idx, choice);
      }
      select.value = choice;
      select.addEventListener('change', function () {
        const val = select.value;
        scryChoices.set(idx, val);
        if (val === 'top') {
          if (!scryTopOrder.includes(idx)) {
            scryTopOrder = scryTopOrder.concat([idx]);
          }
        } else {
          scryTopOrder = scryTopOrder.filter(function (entry) { return entry !== idx; });
        }
        renderScryTopList();
      });
      cardWrap.appendChild(img);
      cardWrap.appendChild(title);
      cardWrap.appendChild(select);
      scryPreview.appendChild(cardWrap);
    });
    renderScryTopList();
  }

  async function fetchScryPreview() {
    if (!stateInput || !stateInput.value) {
      setScryStatus('Shuffle a deck first.', 'warning');
      return;
    }
    const countValue = scryCount ? parseInt(scryCount.value || '1', 10) || 1 : 1;
    try {
      const payload = { state: stateInput.value, count: countValue };
      if (csrfToken) {
        payload.csrf_token = csrfToken;
      }
      const response = await fetch('{{ url_for("views.opening_hand_peek") }}', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(csrfToken ? { 'X-CSRFToken': csrfToken } : {})
        },
        credentials: 'same-origin',
        body: JSON.stringify(payload)
      });
      const data = await response.json().catch(() => null);
      if (!response.ok || !data || !data.ok) {
        const detail = (data && data.error) ? data.error : `Unable to preview cards (HTTP ${response.status}).`;
        setScryStatus(detail, 'danger');
        return;
      }
      scryCards = Array.isArray(data.cards) ? data.cards : [];
      scryChoices = new Map();
      scryTopOrder = scryCards.map(function (_card, idx) { return idx; });
      scryCards.forEach(function (_card, idx) {
        scryChoices.set(idx, 'top');
      });
      if (scryPreviewHint) {
        scryPreviewHint.textContent = `Looking at ${data.count} card${data.count === 1 ? '' : 's'} on top of ${data.deck_name}.`;
      }
      setScryStatus('');
      renderScryPreview();
    } catch (err) {
      console.error(err);
      setScryStatus('Unable to preview cards right now.', 'danger');
    }
  }

  async function applyScryChanges() {
    if (!stateInput || !stateInput.value) {
      setScryStatus('Shuffle a deck first.', 'warning');
      return;
    }
    if (!scryCards.length) {
      setScryStatus('Preview cards first.', 'warning');
      return;
    }
    const mode = scryMode ? (scryMode.value || 'scry') : 'scry';
    const countValue = scryCards.length;
    const bottomOrder = [];
    const graveyardOrder = [];
    scryCards.forEach(function (_card, idx) {
      const choice = scryChoices.get(idx) || 'top';
      if (choice === 'bottom') {
        bottomOrder.push(idx);
      } else if (choice === 'graveyard') {
        graveyardOrder.push(idx);
      }
    });
    const payload = {
      state: stateInput.value,
      count: countValue,
      keep_order: scryTopOrder,
      bottom_order: bottomOrder,
      graveyard_order: graveyardOrder,
      choices: scryCards.map(function (_card, idx) {
        return { index: idx, action: scryChoices.get(idx) || 'top' };
      })
    };
    if (csrfToken) {
      payload.csrf_token = csrfToken;
    }
    const endpoint = mode === 'surveil'
      ? '{{ url_for("views.opening_hand_surveil") }}'
      : '{{ url_for("views.opening_hand_scry") }}';
    try {
      const response = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...(csrfToken ? { 'X-CSRFToken': csrfToken } : {})
        },
        credentials: 'same-origin',
        body: JSON.stringify(payload)
      });
      const data = await response.json().catch(() => null);
      if (!response.ok || !data || !data.ok) {
        const detail = (data && data.error) ? data.error : `Unable to apply changes (HTTP ${response.status}).`;
        setScryStatus(detail, 'danger');
        return;
      }
      if (stateInput) {
        stateInput.value = data.state;
      }
      if (handRemaining && typeof data.remaining === 'number') {
        handRemaining.hidden = false;
        handRemaining.textContent = data.remaining + ' cards remaining';
      }
      if (mode === 'surveil' && data.moved && Array.isArray(data.moved.graveyard)) {
        data.moved.graveyard.forEach(function (card) {
          const payloadCard = normalizeCard(card);
          if (payloadCard) {
            moveCardToBoard(payloadCard, 'graveyard');
          }
        });
      }
      setScryStatus('Applied.', 'success');
      showMessage(`${mode === 'surveil' ? 'Surveil' : 'Scry'} applied.`, 'info');
      updateScryAvailability();
      if (scryModal) {
        const ModalCtor = window.bootstrap && window.bootstrap.Modal
          ? window.bootstrap.Modal
          : (typeof bootstrap !== 'undefined' && bootstrap.Modal ? bootstrap.Modal : null);
        const instance = ModalCtor ? ModalCtor.getOrCreateInstance(scryModal) : null;
        if (instance) {
          instance.hide();
        }
      }
    } catch (err) {
      console.error(err);
      setScryStatus('Unable to apply changes.', 'danger');
    }
  }

  function removeCardById(collection, id) {
    if (!Array.isArray(collection)) {
      return null;
    }
    const index = collection.findIndex(function (card) {
      return card.__uid === id;
    });
    if (index === -1) {
      return null;
    }
    const removed = collection.splice(index, 1);
    return removed.length ? removed[0] : null;
  }

  function createCardElement(card, source, zone) {
    if (!handCardTemplate) {
      return null;
    }
    const fragment = handCardTemplate.content.cloneNode(true);
    const cardEl = fragment.querySelector('.hand-card');
    const img = cardEl ? cardEl.querySelector('img') : null;
    const nameEl = cardEl ? cardEl.querySelector('.name') : null;

    if (!cardEl) {
      return null;
    }

    cardEl.dataset.cardId = card.__uid;
    cardEl.dataset.source = source;
    if (zone) {
      cardEl.dataset.zone = zone;
    } else {
      delete cardEl.dataset.zone;
    }
    cardEl.draggable = true;
    cardEl.classList.toggle('card-tapped', Boolean(card.tapped));

    const imageSrc = card.image || placeholderImage;
    if (img) {
      img.src = imageSrc;
      img.alt = card.name || '';
      if (card.hover) {
        img.dataset.hoverSrc = card.hover;
      } else {
        delete img.dataset.hoverSrc;
      }
    }

    if (nameEl) {
      nameEl.textContent = card.name || 'Card';
    }

    if (card.back_image) {
      cardEl.classList.add('has-back');
      const flipBtn = document.createElement('button');
      flipBtn.type = 'button';
      flipBtn.className = 'card-flip-btn';
      flipBtn.textContent = card.flipped ? 'Front' : 'Back';
      flipBtn.addEventListener('click', function (event) {
        event.preventDefault();
        event.stopPropagation();
        toggleCardFace(card, source, zone || null);
      });
      cardEl.appendChild(flipBtn);
    }

    cardEl.addEventListener('click', function (event) {
      if (event.detail > 1) {
        return;
      }
      handleCardInteraction(cardEl.dataset.cardId, source, zone || null);
    });
    if (source === 'board') {
      cardEl.addEventListener('dblclick', function (event) {
        event.preventDefault();
        if (zone === 'command') {
          const moved = removeCardFromBoard(cardEl.dataset.cardId);
          if (!moved) {
            return;
          }
          moveCommanderToBattlefield(moved);
          closeContextMenu();
          return;
        }
        returnCardToHand(cardEl.dataset.cardId, 'board');
      });
    }
    cardEl.addEventListener('contextmenu', function (event) {
      event.preventDefault();
      openContextMenu(event, card, source, zone || null);
    });
    cardEl.addEventListener('dragstart', function (event) {
      handleDragStart(event, card, source, zone || null);
    });
    cardEl.addEventListener('dragend', handleDragEnd);
    cardEl.addEventListener('dragover', function (event) {
      handleCardDragOver(event, card, zone || null);
    });
    cardEl.addEventListener('drop', function (event) {
      handleCardDrop(event, card, zone || null);
    });

    return cardEl;
  }

  function renderCollection(container, cards, config) {
    if (!container) {
      return;
    }
    const cfg = config || {};
    container.innerHTML = '';

    if (!cards || !cards.length) {
      const empty = document.createElement('div');
      empty.className = cfg.emptyClass || 'text-muted';
      empty.textContent = cfg.emptyText || 'Nothing here yet.';
      container.appendChild(empty);
      return;
    }

    cards.forEach(function (card) {
      const el = createCardElement(card, cfg.source || 'hand', cfg.zone);
      if (!el) {
        return;
      }
      if (typeof cfg.afterRender === 'function') {
        cfg.afterRender(card, el);
      }
      container.appendChild(el);
    });

    if (window.dvAttachCheckerHover) {
      window.dvAttachCheckerHover(container);
    }
  }

  function renderZone(zoneKey) {
    const container = boardContainers[zoneKey];
    if (!container) {
      return;
    }
    const zoneRoot = boardZoneRoots[zoneKey];
    container.innerHTML = '';
    const cards = boardState[zoneKey] || [];
    const keepVisible = zoneKey === 'command' || zoneKey === 'graveyard';
    if (zoneKey === 'graveyard' && graveyardCount) {
      graveyardCount.textContent = String(cards.length || 0);
      graveyardCount.hidden = cards.length === 0;
    }

    if (!cards.length) {
      if (zoneRoot) {
        zoneRoot.hidden = !keepVisible;
      }
      if (keepVisible) {
        const empty = document.createElement('div');
        empty.className = 'board-empty text-muted small';
        empty.textContent = container.dataset.emptyText || 'No cards here yet.';
        container.appendChild(empty);
      }
      return;
    }

    if (zoneRoot) {
      zoneRoot.hidden = false;
    }

    const orderMap = new Map();
    cards.forEach(function (c, idx) {
      orderMap.set(c.__uid, idx);
    });

    const childMap = new Map();
    cards.forEach(function (c) {
      const parentId = c.stack_parent || null;
      if (!parentId) {
        return;
      }
      if (!childMap.has(parentId)) {
        childMap.set(parentId, []);
      }
      childMap.get(parentId).push(c);
    });

    const roots = cards.filter(function (c) {
      return !c.stack_parent || !orderMap.has(c.stack_parent);
    });

    const sortByOrder = function (a, b) {
      return (orderMap.get(a.__uid) || 0) - (orderMap.get(b.__uid) || 0);
    };

    roots.sort(sortByOrder).forEach(function (card) {
      const children = (childMap.get(card.__uid) || []).sort(sortByOrder);
      if (children.length === 0) {
        const singleEl = createCardElement(card, 'board', zoneKey);
        if (singleEl) {
          singleEl.style.removeProperty('--stack-index');
          container.appendChild(singleEl);
        }
        return;
      }

      const stackWrap = document.createElement('div');
      stackWrap.className = 'card-stack';
      const allCards = [card].concat(children);
      const isCreature = function (c) {
        return Boolean(c && c.is_creature);
      };
      allCards.sort(function (a, b) {
        return (isCreature(a) ? 1 : 0) - (isCreature(b) ? 1 : 0);
      });
      const creatureCard = allCards.find(function (entry) {
        return isCreature(entry);
      });
      if (creatureCard) {
        stackWrap.dataset.creatureId = creatureCard.__uid;
        const tapBtn = document.createElement('button');
        tapBtn.type = 'button';
        tapBtn.className = 'stack-tap-btn';
        tapBtn.textContent = creatureCard.tapped ? 'Untap' : 'Tap';
        tapBtn.addEventListener('click', function (event) {
          event.preventDefault();
          event.stopPropagation();
          creatureCard.tapped = !creatureCard.tapped;
          renderBoard();
        });
        stackWrap.appendChild(tapBtn);
      }
      allCards.forEach(function (entry, idx) {
        const el = createCardElement(entry, 'board', zoneKey);
        if (!el) {
          return;
        }
        el.style.setProperty('--stack-index', String(idx));
        stackWrap.appendChild(el);
      });
      container.appendChild(stackWrap);
    });

    if (window.dvAttachCheckerHover) {
      window.dvAttachCheckerHover(container);
    }
  }

  function renderBoard() {
    boardZones.forEach(renderZone);
  }

  function applyHandFan() {
    if (!handGrid) {
      return;
    }
    const cards = Array.from(handGrid.querySelectorAll('.hand-card'));
    const count = cards.length;
    if (!count) {
      return;
    }
    const center = (count - 1) / 2;
    const maxRotation = count <= 3 ? 3 : 4.5;
    const maxOffset = count <= 3 ? 4 : 9;

    cards.forEach(function (cardEl, index) {
      let angle = 0;
      let offset = 0;
      if (center > 0) {
        const ratio = (index - center) / center;
        angle = ratio * maxRotation;
        offset = Math.abs(ratio) * maxOffset;
      }
      cardEl.style.setProperty('--hand-rotate', angle.toFixed(2) + 'deg');
      cardEl.style.setProperty('--hand-offset', offset.toFixed(1) + 'px');
    });
  }

  function untapAllBoardCards() {
    let changed = false;
    boardZones.forEach(function (zone) {
      const cards = boardState[zone] || [];
      cards.forEach(function (card) {
        if (card.tapped) {
          card.tapped = false;
          changed = true;
        }
      });
    });
    if (changed) {
      renderBoard();
    }
    return changed;
  }

  function renderHand() {
    renderCollection(handGrid, handCards, {
      source: 'hand',
      emptyText: 'Shuffle a deck to see your opening seven.',
      emptyClass: 'text-muted small'
    });
    applyHandFan();
  }

  function classifyCard(card) {
    if (!card) {
      return 'permanents';
    }
    if (card.boardZone && boardState[card.boardZone]) {
      return card.boardZone;
    }
    const hintedZone = card.zone_hint || card.zoneHint || '';
    if (hintedZone && boardState[hintedZone]) {
      return hintedZone;
    }
    if (card.lastBoardZone && boardState[card.lastBoardZone]) {
      return card.lastBoardZone;
    }
    if (card.is_land) {
      return 'lands';
    }
    if (card.is_creature) {
      return 'creatures';
    }
    if (card.is_instant || card.is_sorcery) {
      return 'graveyard';
    }
    if (card.is_permanent) {
      return 'permanents';
    }
    return 'permanents';
  }

  function moveCommanderToBattlefield(card) {
    if (!card) {
      return;
    }
    const targetZone = classifyCard(Object.assign({}, card, { boardZone: null, lastBoardZone: null }));
    moveCardToBoard(card, targetZone);
  }

  function removeCardFromBoard(cardId) {
    let removed = null;
    boardZones.some(function (zone) {
      const cards = boardState[zone];
      const index = cards.findIndex(function (card) {
        return card.__uid === cardId;
      });
      if (index !== -1) {
        removed = cards.splice(index, 1)[0];
        // Detach any children that were stacked on this card
        cards.forEach(function (c) {
          if (c.stack_parent === cardId) {
            c.stack_parent = null;
          }
        });
        return true;
      }
      return false;
    });
    return removed;
  }

  function findCardOnBoard(cardId) {
    let found = null;
    boardZones.some(function (zone) {
      const cards = boardState[zone];
      const match = cards.find(function (card) {
        return card.__uid === cardId;
      });
      if (match) {
        found = match;
        return true;
      }
      return false;
    });
    return found;
  }

  function insertCardIntoBoardZone(card, zone, beforeId) {
    const zoneCards = boardState[zone];
    if (!Array.isArray(zoneCards)) {
      return;
    }
    let insertIndex = -1;
    if (typeof beforeId === 'string' && beforeId) {
      insertIndex = zoneCards.findIndex(function (entry) {
        return entry.__uid === beforeId;
      });
    }
    if (insertIndex < 0 || insertIndex > zoneCards.length) {
      insertIndex = zoneCards.length;
    }
    zoneCards.splice(insertIndex, 0, card);
  }

  function moveCardToBoard(card, preferredZone, beforeId, stackParentId) {
    if (!card) {
      return;
    }
    const zone = preferredZone && boardState[preferredZone] ? preferredZone : classifyCard(card);
    removeCardFromBoard(card.__uid);
    card.boardZone = zone;
    card.lastBoardZone = zone;
    card.stack_parent = stackParentId || null;
    if (zone === 'graveyard' || zone === 'command') {
      card.tapped = false;
    }
    insertCardIntoBoardZone(card, zone, beforeId);
    renderBoard();
  }

  function borrowCardFromSource(cardId, source) {
    let card = null;
    if (source === 'board') {
      card = removeCardFromBoard(cardId);
    } else if (source === 'hand') {
      card = removeCardById(handCards, cardId);
      if (card) {
        renderHand();
      }
    }
    if (card) {
      if (source !== 'board') {
        delete card.boardZone;
        card.tapped = false;
      }
      card.stack_parent = null;
    }
    return card;
  }

  function returnCardToHand(cardId, source) {
    if (!cardId) {
      return;
    }
    const origin = source || 'board';
    const card = borrowCardFromSource(cardId, origin);
    if (!card) {
      return;
    }
    card.lastBoardZone = card.boardZone || card.lastBoardZone || null;
    delete card.boardZone;
    card.tapped = false;
    handCards.push(card);
    renderHand();
    renderBoard();
    closeContextMenu();
  }

  function placeDraggedCard(targetZone, beforeId) {
    if (!dragContext) {
      return;
    }
    if (!targetZone || !boardState[targetZone]) {
      dragContext = null;
      return;
    }

    const { cardId, source } = dragContext;
    let card = borrowCardFromSource(cardId, source);
    if (!card) {
      dragContext = null;
      return;
    }

    const stackParent = beforeId && beforeId !== cardId ? beforeId : null;
    moveCardToBoard(card, targetZone, beforeId, stackParent);
    dragContext = null;
    clearActiveDropTarget();
    closeContextMenu();
  }

  function setActiveDropTarget(element) {
    if (activeDropTarget === element) {
      return;
    }
    if (activeDropTarget) {
      activeDropTarget.classList.remove('drop-target-active');
    }
    activeDropTarget = element;
    if (activeDropTarget) {
      activeDropTarget.classList.add('drop-target-active');
    }
  }

  function clearActiveDropTarget() {
    if (!activeDropTarget) {
      return;
    }
    activeDropTarget.classList.remove('drop-target-active');
    activeDropTarget = null;
  }

  function handleDragStart(event, card, source, zone) {
    if (!card) {
      return;
    }
    if (event.dataTransfer) {
      try {
        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setData('text/plain', card.__uid);
      } catch (err) {
        // ignore
      }
    }
    dragContext = {
      cardId: card.__uid,
      source: source,
      zone: zone || card.boardZone || null,
      originalIndex: null
    };
    if (dragContext.zone && boardState[dragContext.zone]) {
      dragContext.originalIndex = boardState[dragContext.zone].findIndex(function (entry) {
        return entry.__uid === card.__uid;
      });
    }
    clearActiveDropTarget();
    closeContextMenu();
  }

  function handleDragEnd() {
    dragContext = null;
    clearActiveDropTarget();
  }

  function handleZoneDragOver(event, zone) {
    if (!dragContext) {
      return;
    }
    if (event && typeof event.preventDefault === 'function') {
      event.preventDefault();
    }
    if (event && typeof event.stopPropagation === 'function') {
      event.stopPropagation();
    }
    if (event && event.dataTransfer) {
      event.dataTransfer.dropEffect = 'move';
    }
    const container = boardContainers[zone];
    if (container) {
      setActiveDropTarget(container);
    }
  }

  function handleZoneDrop(event, zone) {
    if (event && typeof event.preventDefault === 'function') {
      event.preventDefault();
    }
    if (event && typeof event.stopPropagation === 'function') {
      event.stopPropagation();
    }
    if (!dragContext) {
      return;
    }
    placeDraggedCard(zone, null);
  }

  function handleCardDragOver(event, targetCard, zone) {
    if (!dragContext) {
      return;
    }
    if (targetCard && dragContext.cardId === targetCard.__uid) {
      return;
    }
    if (event && typeof event.preventDefault === 'function') {
      event.preventDefault();
    }
    if (event && typeof event.stopPropagation === 'function') {
      event.stopPropagation();
    }
    if (event && event.dataTransfer) {
      event.dataTransfer.dropEffect = 'move';
    }
    const element = event.currentTarget;
    if (element) {
      setActiveDropTarget(element);
    }
  }

  function handleCardDrop(event, targetCard, zone) {
    if (event && typeof event.preventDefault === 'function') {
      event.preventDefault();
    }
    if (event && typeof event.stopPropagation === 'function') {
      event.stopPropagation();
    }
    if (!dragContext || !targetCard) {
      return;
    }
    if (dragContext.cardId === targetCard.__uid && (!zone || (dragContext.zone === zone))) {
      dragContext = null;
      clearActiveDropTarget();
      renderBoard();
      return;
    }
    const targetZone = zone || targetCard.boardZone || dragContext.zone;
    if (!targetZone || !boardState[targetZone]) {
      dragContext = null;
      clearActiveDropTarget();
      return;
    }
    placeDraggedCard(targetZone, targetCard.__uid);
  }

  function ensureContextMenu() {
    if (contextMenuRef) {
      return contextMenuRef;
    }
    const menu = document.createElement('div');
    menu.id = 'cardContextMenu';
    menu.className = 'card-context-menu shadow-lg';
    menu.tabIndex = -1;
    menu.hidden = true;
    document.body.appendChild(menu);
    contextMenuRef = menu;

    document.addEventListener('click', function (event) {
      if (!contextMenuRef || contextMenuRef.hidden) {
        return;
      }
      if (!contextMenuRef.contains(event.target)) {
        closeContextMenu();
      }
    });
    document.addEventListener('contextmenu', function (event) {
      if (!contextMenuRef || contextMenuRef.hidden) {
        return;
      }
      if (!contextMenuRef.contains(event.target)) {
        closeContextMenu();
      }
    });
    window.addEventListener('resize', closeContextMenu);
    document.addEventListener('keydown', function (event) {
      if (event.key === 'Escape') {
        closeContextMenu();
      }
    });
    return menu;
  }

  function closeContextMenu() {
    if (!contextMenuRef) {
      return;
    }
    contextMenuRef.hidden = true;
    contextMenuRef.innerHTML = '';
    contextCard = null;
  }

  function duplicateCardToZone(card, zone) {
    const cloneSource = Object.assign({}, card);
    delete cloneSource.__uid;
    cloneSource.tapped = false;
    const copy = normalizeCard(cloneSource);
    if (!copy) {
      return;
    }
    moveCardToBoard(copy, zone || classifyCard(copy));
  }

  function openContextMenu(event, card, source, zone) {
    const menu = ensureContextMenu();
    if (!menu) {
      return;
    }
    closeContextMenu();

    const isBoardCard = source === 'board';
    const currentZone = zone || card.boardZone || null;
    const options = [];
    const cardId = card.__uid;

    if (isBoardCard) {
      options.push({
        label: card.tapped ? 'Untap' : 'Tap',
        action: function () {
          card.tapped = !card.tapped;
          renderBoard();
        }
      });
      if (card.back_image) {
        options.push({
          label: card.flipped ? 'Show Front' : 'Show Back',
          action: function () {
            toggleCardFace(card, source, currentZone);
          }
        });
      }
      options.push({
        label: 'Return to Hand',
        action: function () {
          returnCardToHand(cardId, 'board');
        }
      });
    } else if (source !== 'hand') {
      options.push({
        label: 'Return to Hand',
        action: function () {
          returnCardToHand(cardId, source);
        }
      });
    }

    if (!isBoardCard && card.back_image) {
      options.push({
        label: card.flipped ? 'Show Front' : 'Show Back',
        action: function () {
          toggleCardFace(card, source, currentZone);
        }
      });
    }

    if (currentZone !== 'graveyard') {
      options.push({
        label: 'Move to Graveyard',
        action: function () {
          const item = borrowCardFromSource(cardId, isBoardCard ? 'board' : source);
          if (!item) {
            return;
          }
          moveCardToBoard(item, 'graveyard');
        }
      });
    }

    if (currentZone !== 'graveyard') {
      options.push({
        label: 'Create Copy (Token)',
        action: function () {
          const targetZone = isBoardCard ? currentZone : null;
          duplicateCardToZone(card, targetZone);
        }
      });
    }

    if (currentZone !== 'command') {
      options.push({
        label: 'Move to Command Zone',
        action: function () {
          const item = borrowCardFromSource(cardId, isBoardCard ? 'board' : source);
          if (!item) {
            return;
          }
          moveCardToBoard(item, 'command');
        }
      });
    }

    const battlefieldTargets = [
      { zone: 'creatures', label: 'Battlefield - Creatures' },
      { zone: 'permanents', label: 'Battlefield - Noncreature' },
      { zone: 'lands', label: 'Battlefield - Lands' }
    ];
    battlefieldTargets.forEach(function (entry) {
      if (currentZone === entry.zone) {
        return;
      }
      options.push({
        label: 'Move to ' + entry.label,
        action: function () {
          const item = borrowCardFromSource(cardId, isBoardCard ? 'board' : source);
          if (!item) {
            return;
          }
          moveCardToBoard(item, entry.zone);
        }
      });
    });

    if (!options.length) {
      return;
    }

    contextCard = { card: card, source: source, zone: currentZone };
    menu.innerHTML = '';
    options.forEach(function (opt) {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'card-context-item';
      button.textContent = opt.label;
      button.addEventListener('click', function () {
        opt.action();
        closeContextMenu();
      });
      menu.appendChild(button);
    });

    const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 1024;
    const viewportHeight = window.innerHeight || document.documentElement.clientHeight || 768;
    const menuRect = menu.getBoundingClientRect();
    const approximateWidth = menuRect.width || 220;
    const approximateHeight = menuRect.height || (options.length * 36 + 12);
    let left = event.clientX;
    let top = event.clientY;
    if (left + approximateWidth > viewportWidth) {
      left = Math.max(8, viewportWidth - approximateWidth - 8);
    }
    if (top + approximateHeight > viewportHeight) {
      top = Math.max(8, viewportHeight - approximateHeight - 8);
    }
    menu.style.left = left + 'px';
    menu.style.top = top + 'px';
    menu.hidden = false;
    menu.focus({ preventScroll: true });
  }

  function setHand(cards) {
    if (!Array.isArray(cards) || !cards.length) {
      handCards = [];
    } else {
      handCards = cards.map(function (card) {
        return normalizeCard(card);
      }).filter(Boolean);
    }
    renderHand();
  }

  function addDraw(card, remaining, deckName) {
    const normalized = normalizeCard(card);
    if (!normalized) {
      return;
    }
    handCards.push(normalized);
    renderHand();
    if (typeof remaining === 'number' && handRemaining) {
      handRemaining.hidden = false;
      handRemaining.textContent = remaining + ' cards remaining';
    }
    if (handDeckName && deckName) {
      handDeckName.textContent = deckName;
    }
  }

  function handleCardInteraction(cardId, source, zone) {
    if (!cardId) {
      return;
    }

    if (source === 'board') {
      if (zone === 'command') {
        const moved = removeCardFromBoard(cardId);
        if (!moved) {
          return;
        }
        moveCommanderToBattlefield(moved);
        closeContextMenu();
        return;
      }
      const card = findCardOnBoard(cardId);
      if (card) {
        card.tapped = !card.tapped;
        renderBoard();
        closeContextMenu();
      }
      return;
    }

    let card = null;
    if (source === 'hand') {
      card = removeCardById(handCards, cardId);
      renderHand();
    }

    if (!card) {
      return;
    }

    moveCardToBoard(card);
    closeContextMenu();
  }

  function resetSimulator() {
    if (stateInput) {
      stateInput.value = '';
    }
    handCards = [];
    boardZones.forEach(function (zone) {
      boardState[zone] = [];
    });
    seedCommandZone();
    renderHand();
    renderBoard();
    if (handRemaining) {
      handRemaining.hidden = true;
      handRemaining.textContent = '';
    }
    if (drawBtn) {
      drawBtn.disabled = true;
    }
    showMessage('');
    showWarnings([]);
    closeContextMenu();
    updateActionVisibility();
  }

  if (fetchCardForm && fetchCardModalEl) {
    const modalFactory = window.bootstrap && window.bootstrap.Modal
      ? window.bootstrap.Modal
      : (typeof bootstrap !== 'undefined' && bootstrap.Modal ? bootstrap.Modal : null);
    const fetchModal = modalFactory ? modalFactory.getOrCreateInstance(fetchCardModalEl) : null;

    const handleFetchSubmit = function (event) {
      if (event) {
        event.preventDefault();
        event.stopPropagation();
      }
      const formData = new FormData(fetchCardForm);
        const selectedValue = (formData.get('name') || '').toString().trim();
        const searchValue = (fetchCardSearch ? fetchCardSearch.value : '').toString().trim();
      const imageUrl = (formData.get('image') || '').toString().trim();
      const zoneValue = (formData.get('zone') || 'hand').toString();

      const selectedOption = selectedValue && fetchCardOptions[selectedValue] ? fetchCardOptions[selectedValue] : null;
      const cardName = selectedOption ? selectedOption.name : searchValue || selectedValue;

      if (!cardName) {
        fetchCardForm.reportValidity();
        if (!selectedOption && fetchCardSearch) {
          fetchCardSearch.focus();
        }
        return;
      }

      if (!selectedOption) {
        const deckNames = deckNameSetForSelection(currentDeckId());
        const normalizedName = normalizeCardName(cardName);
        if (deckNames.size && isBasicLandName(normalizedName) && !deckNames.has(normalizedName)) {
          showMessage('That basic land is not in this deck.', 'warning');
          if (fetchCardSearch) {
            fetchCardSearch.focus();
          }
          return;
        }
      }

      const inferredImage = selectedOption ? (selectedOption.image || selectedOption.hover || null) : null;
      const inferredHover = selectedOption ? (selectedOption.hover || selectedOption.image || null) : null;
      const inferredBackImage = selectedOption ? (selectedOption.back_image || null) : null;
      const inferredBackHover = selectedOption ? (selectedOption.back_hover || selectedOption.back_image || null) : null;
      const inferredTypeLine = selectedOption ? selectedOption.type_line : '';
      const inferredIsCreature = selectedOption ? Boolean(selectedOption.is_creature) : false;
      const inferredIsLand = selectedOption ? Boolean(selectedOption.is_land) : false;
      const inferredIsInstant = selectedOption ? Boolean(selectedOption.is_instant) : false;
      const inferredIsSorcery = selectedOption ? Boolean(selectedOption.is_sorcery) : false;
      const inferredIsPermanent = selectedOption ? Boolean(selectedOption.is_permanent) : false;
      const inferredZoneHint = selectedOption ? (selectedOption.zone_hint || '') : '';

      const payload = normalizeCard({
        name: cardName,
        image: imageUrl || inferredImage || placeholderImage,
        hover: imageUrl || inferredHover || inferredImage || placeholderImage,
        back_image: inferredBackImage,
        back_hover: inferredBackHover,
        type_line: inferredTypeLine,
        is_creature: inferredIsCreature,
        is_land: inferredIsLand,
        is_instant: inferredIsInstant,
        is_sorcery: inferredIsSorcery,
        is_permanent: inferredIsPermanent,
        zone_hint: inferredZoneHint || 'permanents',
      });

      if (!payload) {
        return;
      }

      if (zoneValue === 'hand') {
        handCards.push(payload);
        renderHand();
      } else {
        const parts = zoneValue.split(':');
        const forcedZone = parts.length > 1 ? parts[1] : null;
        moveCardToBoard(payload, forcedZone);
      }

      if (fetchModal) {
        fetchModal.hide();
      }
      closeContextMenu();
      fetchCardForm.reset();
      if (fetchCardSearch) {
        fetchCardSearch.value = '';
        applyFetchFilter('');
      }
      setFetchSelection('');
      if (fetchZoneSelect) {
        const zoneInput = fetchZoneSelect.querySelector('[data-dv-select-input]');
        if (zoneInput) {
          zoneInput.value = 'hand';
        }
        const zoneButton = fetchZoneSelect.querySelector('[data-dv-select-option][data-value="hand"]');
        const zoneLabel = zoneButton ? (zoneButton.dataset.label || zoneButton.textContent.trim()) : 'Put into hand';
        updateDvSelect(fetchZoneSelect, 'hand', zoneLabel, { trigger: false, hide: false });
      }
    };

    fetchCardForm.addEventListener('submit', handleFetchSubmit);
    if (fetchCardSubmit) {
      fetchCardSubmit.addEventListener('click', handleFetchSubmit);
    }

    fetchCardModalEl.addEventListener('shown.bs.modal', function () {
      populateFetchList(currentDeckId());
      if (fetchZoneSelect) {
        const zoneInput = fetchZoneSelect.querySelector('[data-dv-select-input]');
        if (zoneInput) {
          zoneInput.value = 'hand';
        }
        const zoneButton = fetchZoneSelect.querySelector('[data-dv-select-option][data-value="hand"]');
        const zoneLabel = zoneButton ? (zoneButton.dataset.label || zoneButton.textContent.trim()) : 'Put into hand';
        updateDvSelect(fetchZoneSelect, 'hand', zoneLabel, { trigger: false, hide: false });
      }
      if (fetchCardSearch) {
        fetchCardSearch.value = '';
        setFetchSelection('');
        applyFetchFilter('');
        setTimeout(function () {
          fetchCardSearch.focus({ preventScroll: true });
        }, 50);
      }
    });

    fetchCardModalEl.addEventListener('hidden.bs.modal', function () {
      fetchCardForm.reset();
      if (fetchZoneSelect) {
        const zoneInput = fetchZoneSelect.querySelector('[data-dv-select-input]');
        if (zoneInput) {
          zoneInput.value = 'hand';
        }
        const zoneButton = fetchZoneSelect.querySelector('[data-dv-select-option][data-value="hand"]');
        const zoneLabel = zoneButton ? (zoneButton.dataset.label || zoneButton.textContent.trim()) : 'Put into hand';
        updateDvSelect(fetchZoneSelect, 'hand', zoneLabel, { trigger: false, hide: false });
      }
      setFetchSelection('');
      if (fetchCardSearch) {
        fetchCardSearch.value = '';
      }
      applyFetchFilter('');
    });
  }

  if (resetBtn) {
    resetBtn.addEventListener('click', resetSimulator);
  }

  if (shuffleBtn) {
    shuffleBtn.addEventListener('click', async function () {
      showMessage('');
      showWarnings([]);
      const deckId = currentDeckId();
      const deckList = (deckListInput ? deckListInput.value : '').trim();
      const commander = (commanderInput ? commanderInput.value : '').trim();

      if (!deckId && !deckList) {
        showMessage('Choose a deck or paste a deck list before shuffling.', 'warning');
        return;
      }

      shuffleBtn.disabled = true;
      if (drawBtn) {
        drawBtn.disabled = true;
      }
      showMessage('Shuffling...', 'info');

      try {
        const payload = {
          deck_id: deckId || null,
          deck_list: deckList || null,
          commander_name: commander
        };
        if (csrfToken) {
          payload.csrf_token = csrfToken;
        }
        const response = await fetch('{{ url_for("views.opening_hand_shuffle") }}', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(csrfToken ? { 'X-CSRFToken': csrfToken } : {})
          },
          credentials: 'same-origin',
          body: JSON.stringify(payload)
        });

        let data = null;
        try {
          data = await response.json();
        } catch (_) {
          data = null;
        }

        if (!response.ok || !data || !data.ok) {
          const detail = (data && data.error) ? data.error : `Unable to shuffle deck (HTTP ${response.status}).`;
          showMessage(detail, 'danger');
          return;
        }

        showMessage('Opening hand ready from ' + data.deck_name + '.', 'success');
        if (stateInput) {
          stateInput.value = data.state;
        }
        if (handDeckName) {
          handDeckName.textContent = data.deck_name;
        }
        if (handRemaining) {
          handRemaining.hidden = false;
          handRemaining.textContent = data.remaining + ' cards remaining';
        }

        setHand(data.hand);
        boardZones.forEach(function (zone) {
          boardState[zone] = [];
        });
        if (Array.isArray(data.commanders)) {
          setCommanderSeed(data.commanders);
        }
        seedCommandZone();
        renderBoard();
        closeContextMenu();
        if (drawBtn) {
          drawBtn.disabled = false;
        }
        updateScryAvailability();
        showWarnings(data.warnings || []);
      } catch (err) {
        console.error(err);
        showMessage('An unexpected error occurred while shuffling.', 'danger');
      } finally {
        shuffleBtn.disabled = false;
      }
    });
  }

  if (drawBtn) {
    drawBtn.addEventListener('click', async function () {
      const state = stateInput ? stateInput.value : '';
      if (!state) {
        return;
      }
      drawBtn.disabled = true;

      try {
        const payload = { state: state };
        if (csrfToken) {
          payload.csrf_token = csrfToken;
        }
        const response = await fetch('{{ url_for("views.opening_hand_draw") }}', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            ...(csrfToken ? { 'X-CSRFToken': csrfToken } : {})
          },
          credentials: 'same-origin',
          body: JSON.stringify(payload)
        });

        let data = null;
        try {
          data = await response.json();
        } catch (_) {
          data = null;
        }

        if (!response.ok || !data || !data.ok) {
          const detail = (data && data.error) ? data.error : `Unable to draw (HTTP ${response.status}).`;
          showMessage(detail, 'warning');
          if (data && data.state && stateInput) {
            stateInput.value = data.state;
          }
          if (data && typeof data.remaining === 'number' && handRemaining) {
            handRemaining.hidden = false;
            handRemaining.textContent = data.remaining + ' cards remaining';
          }
          drawBtn.disabled = !!(data && data.remaining === 0);
          return;
        }

        if (stateInput) {
          stateInput.value = data.state;
        }
        if (handRemaining) {
          handRemaining.hidden = false;
          handRemaining.textContent = data.remaining + ' cards remaining';
        }

        addDraw(data.card, data.remaining, data.deck_name);
        showMessage('');
        drawBtn.disabled = data.remaining <= 0;
        updateScryAvailability();
      } catch (err) {
        console.error(err);
        showMessage('An unexpected error occurred while drawing.', 'danger');
        drawBtn.disabled = false;
      }
    });
  }

  if (deckSelectWrapper) {
    deckSelectWrapper.addEventListener('dv-select:ready', function (event) {
      const value = event.detail && event.detail.value ? event.detail.value : '';
      populateFetchList(value);
      updateTokenPicker(value);
      updateActionVisibility();
    });
    deckSelectWrapper.addEventListener('dv-select:change', function (event) {
      const value = event.detail && event.detail.value ? event.detail.value : '';
      if (value && deckListInput && deckListInput.value.trim()) {
        deckListInput.value = '';
      }
      populateFetchList(value);
      updateTokenPicker(value);
      updateActionVisibility();
    });
    refreshDvSelect(deckSelectWrapper);
    const initialVal = deckSelectInput ? (deckSelectInput.value || '') : '';
    const initialLabel = deckSelectLabelEl ? deckSelectLabelEl.textContent.trim() : 'Select a deck';
    deckSelectWrapper.dispatchEvent(new CustomEvent('dv-select:ready', {
      detail: { value: initialVal, label: initialLabel }
    }));
  }

  if (deckListInput) {
    deckListInput.addEventListener('input', updateActionVisibility);
  }

  if (deckPickerApply) {
    deckPickerApply.addEventListener('click', () => {
      if (deckSelectWrapper) {
        updateDvSelect(deckSelectWrapper, '', 'Select a deck', { trigger: true, hide: true });
      }
      populateFetchList(currentDeckId());
      updateTokenPicker(currentDeckId());
      updateActionVisibility();
      resetSimulator();
      if (shuffleBtn) {
        shuffleBtn.click();
      }
    });
  }

  if (deckPickerModal) {
    deckPickerModal.addEventListener('shown.bs.modal', () => {
      populateFetchList(currentDeckId());
      if (deckListInput) {
        setTimeout(() => deckListInput.focus({ preventScroll: true }), 60);
      }
    });
    deckPickerModal.addEventListener('hidden.bs.modal', () => {
      updateActionVisibility();
    });
  }

  if (tokenPickerModal) {
    const ModalCtor = window.bootstrap && window.bootstrap.Modal
      ? window.bootstrap.Modal
      : (typeof bootstrap !== 'undefined' && bootstrap.Modal ? bootstrap.Modal : null);
    tokenModalInstance = ModalCtor ? ModalCtor.getOrCreateInstance(tokenPickerModal) : null;

    tokenPickerModal.addEventListener('show.bs.modal', function () {
      if (tokenPickerSearch) {
        tokenPickerSearch.value = '';
      }
      if (tokenAllSearch) {
        tokenAllSearch.value = '';
      }
      const deckId = currentDeckId();
      const deckListActive = !deckId && (deckListInput ? deckListInput.value.trim() : '');
      lastTokenDeckId = deckId;
      renderTokenList(deckId);
      setTokenStatus(deckId || deckListActive ? '' : 'Select a deck first.');
      applyTokenFilter('');
      clearTokenAllResults();
    });

    tokenPickerModal.addEventListener('hidden.bs.modal', function () {
      setTokenStatus('');
    });
  }

  if (scryModal) {
    scryModal.addEventListener('show.bs.modal', function () {
      resetScryState();
      if (scryCount) {
        scryCount.value = '1';
      }
    });
    scryModal.addEventListener('shown.bs.modal', function () {
      if (scryCount) {
        scryCount.focus({ preventScroll: true });
      }
      fetchScryPreview();
    });
    scryModal.addEventListener('hidden.bs.modal', function () {
      resetScryState();
    });
  }

  if (scryPreviewBtn) {
    scryPreviewBtn.addEventListener('click', function () {
      fetchScryPreview();
    });
  }

  if (scryMode) {
    scryMode.addEventListener('change', function () {
      renderScryPreview();
    });
  }

  if (scryApplyBtn) {
    scryApplyBtn.addEventListener('click', function () {
      applyScryChanges();
    });
  }

  if (tokenPickerSearch) {
    tokenPickerSearch.addEventListener('input', function (event) {
      applyTokenFilter(event.target.value || '');
    });
  }

  if (tokenAllSearch) {
    tokenAllSearch.addEventListener('input', function (event) {
      const value = event.target.value || '';
      if (tokenAllSearchTimer) {
        clearTimeout(tokenAllSearchTimer);
      }
      tokenAllSearchTimer = setTimeout(function () {
        fetchTokenAllResults(value);
      }, 200);
    });
  }

  if (tokenAllCustomBtn) {
    tokenAllCustomBtn.addEventListener('click', function () {
      const name = (tokenAllSearch ? tokenAllSearch.value : '').trim();
      if (!name) {
        return;
      }
      addTokenToBoard({
        name: name,
        image: null,
        hover: null,
        type_line: `Token  ${name}`,
        is_creature: false,
        is_land: false,
        is_instant: false,
        is_sorcery: false,
        is_permanent: true,
        zone_hint: 'permanents',
      });
      if (tokenModalInstance) {
        tokenModalInstance.hide();
      }
      setTokenStatus(`Added ${name} token.`, 'success');
    });
  }

  if (tokenPickerCustomBtn) {
    tokenPickerCustomBtn.addEventListener('click', function () {
      const name = (tokenPickerSearch ? tokenPickerSearch.value : '').trim();
      if (!name) {
        return;
      }
      addTokenToBoard({
        name: name,
        image: null,
        hover: null,
        type_line: `Token  ${name}`,
        is_creature: false,
        is_land: false,
        is_instant: false,
        is_sorcery: false,
        is_permanent: true,
        zone_hint: 'permanents',
      });
      if (tokenModalInstance) {
        tokenModalInstance.hide();
      }
      setTokenStatus(`Added ${name} token.`, 'success');
    });
  }

  if (newDeckBtn) {
    newDeckBtn.addEventListener('click', function () {
      window.location.href = '{{ url_for("views.opening_hand") }}';
    });
  }

  if (fetchZoneSelect) {
    refreshDvSelect(fetchZoneSelect);
    const zoneButton = fetchZoneSelect.querySelector('[data-dv-select-option][data-value="hand"]');
    const zoneLabel = zoneButton ? (zoneButton.dataset.label || zoneButton.textContent.trim()) : 'Put into hand';
    updateDvSelect(fetchZoneSelect, 'hand', zoneLabel, { trigger: false, hide: false });
  }

  populateFetchList(currentDeckId());
  updateTokenPicker(currentDeckId());
  resetSimulator();
  updateActionVisibility();
  syncActionBarSpacing();

  if (handActionBar && window.ResizeObserver) {
    const observer = new ResizeObserver(() => {
      syncActionBarSpacing();
    });
    observer.observe(handActionBar);
  }

  window.addEventListener('resize', syncActionBarSpacing, { passive: true });
})();
</script>

{% endblock %}
